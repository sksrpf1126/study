# **_자바의 상속_**

- ## **_상속?_**

  자바에서 상속을 복습할 때 찾아본 글(https://hevton.tistory.com/335)이 있다.

  이 글을 읽기 전까지 나는 자식의 인스턴스를 만들 때에 부모의 인스턴스를 만들고 나서 자식의 인스턴스를 만들고, 부모의 인스턴스를 참조하는 줄 알았다.

  </br>

  ```java
  public class ConstructorEx {
    public static void main(String[] args) {
        Bclass bclass = new Bclass();
        System.out.println(bclass.x);
    }
  }

  class Aclass{
      int x;

      {
          System.out.println("Aclass 초기화블럭");
      }
      public Aclass(){
          System.out.println("Aclass 기본생성자");
          this.x = 10;
      }
  }

  class Bclass extends Aclass{
      int x;

      {
          System.out.println("Bclass 초기화블럭");
      }

      public Bclass(){
          System.out.println("Bclass 기본생성자");
          this.x = 20;
      }
  }

  실행결과 :
  Aclass 초기화블럭
  Aclass 기본생성자
  Bclass 초기화블럭
  Bclass 기본생성자
  20
  ```

  생성자간의 실행 순서

  자식 클래스 생성자 호출 -> 자식 생성자의 첫 줄에 부모 생성자를 호출하는 부분이 없다면 자동으로 부모 클래스의 기본 생성자 호출 -> 부모 클래스 생성자 실행 -> 자식 클래스 생성자 실행

  나는 이 부분에서 생성자에 의해 부모 클래스에 대한 인스턴스가 우선적으로 만들어지고, 이후 자식 클래스에 대한 인스턴스가 만들어져서 부모의 인스턴스를 참조하는 방식 즉, Heap영역에 2개의 인스턴스가 만들어지는 줄 알았지만 내가 읽은 글에서의 생각은 달랐다.

  **_위 글을 정리하자면_**

  상속관계에 의해 자식 클래스에 대한 인스턴스를 만들때에 Heap 영역에 자식 클래스의 인스턴스에 대한 메모리 공간 하나만을 할당한 후에 부모 클래스의 멤버변수들을 초기화 과정(기본값 초기화 -> 명시적 초기화 -> 초기화 블럭에 의한 초기화 -> 생성자에 의한 초기화)을 거쳐서 메모리 공간에 할당하고, 이후에 자식 멤버변수들 또한 같은 방식으로 하여 같은 메모리 공간에 할당이 된다.

  같은 메모리 공간이지만 명시적으로 부모와 자식을 나누어서 저장이 되기 때문에 구분이 가능하며 메서드는 vtable이라는 메모리 영역에 따로 저장이 된다. 그래서 부모와 자식의 멤버변수 또는 오버라이딩된 메서드를 호출할 때 우선적으로 자식에 존재하는 변수나 메서드를 사용하고, 없을 경우에 부모의 것을 사용한다는 것이다.

  그런데 **_this_** 를 자신의 인스턴스를 참조하는 참조변수라 하고, **_super_**는 자식클래스가 상속받은 부모클래스를 참조하는데 사용되는 참조변수라 한다.

  내가 생각한 대로라면, this는 자식의 인스턴스만을 super는 다른 메모리 공간의 부모의 인스턴스를 참조한다는 것이 되는데 그럼 글에서 설명한 방식에서의 this랑 super는 자식의 인스턴스와 부모의 인스턴스를 구분하는 용도로 쓰이는 것인가?

  ## **_해답이 나오면 내용을 추가할 것_**

</br>

---

# **_참고_**

- https://hevton.tistory.com/335 [상속에 대한 이해]
