# **_객체지향(OOP)특징_**

언어에는 객체지향언어와 절차지향언어로 크게 나뉩니다. 자바는 이 중에서 객체지향언어에 속합니다. 절차지향언어에는 대표적으로 C언어가 존재합니다.

그럼 둘의 차이는 무엇이고, 어떠한 것을 더 많이 사용할까요?

</br>

## **_절차지향_**

"절차" 그러니까 특정 행동을 할 때에 그 행동의 순서를 정의해놓고, 그 순서들을 순서대로 호출하여 실행시키는 방식입니다.

예를들어, 자동차 제조가 있습니다. 자동차 제조에는 간단하게 아래의 순서를 가집니다.

1. 엔진 제작
2. 차체 제작
3. 핸들 제작
4. 의자 제작
5. 바퀴 제작

위 절차로 정의해놓았다면, 당연히 절차지향이기 때문에 서로의 순서를 마음대로 바꾸는 것도, 분리를 시키는 것도 불가할 것입니다. 위 순서로 정의해놓음에 따라 세부 동작들 또한 그러한 순서를 가정하에 제작에 들어가기 때문입니다.

```
그러면 순서와 상관없이 그러니까 순서를 가정하지 않고 제작에만 초점을 맞추면 되지 않나요? 에 순간 의문이 들었습니다.
- 순서가 의미가 없어지는 순간, 절차지향이라고는 할 수 없다고 저는 생각합니다. 그리고 이러한 의문들 속에서 나온 방법이 "객체지향"이라고 생각합니다.
```

그럼 이러한 가정하에 만약에 핸들이 고장이 나서 새롭게 제작을 해야한다면 어떻게 해야할까요?

여기서 절차지향의 단점이 나타나는 것입니다.

컴퓨터의 동작 방식이 절차지향과 거의 유사하기 때문에 속도는 빠르다는 장점이 존재하지만 위의 문제에 의해 유지보수가 어려우며, 순서를 엄격하게 정의해 놓을수록 재생산성과 유지보수가 어려울 것입니다.

</br>

## **_객체지향_**

객체지향은 위의 절차지향의 단점을 극복했습니다.  
엔진, 차체, 핸들, 의자, 바퀴를 모두 객체로 정의해놓고, 제작에 해당하는 행위 또한 각자의 객체에 정의해 놓습니다.

이러면 필요할 때마다 특정 객체만 제작에 들어갈 수 있으며, 순서 또한 자유자재로 변경이 가능합니다. 절차 순서의 가정하에 제작에 들어가는 방식이 아니기 때문입니다.

이러한 이유 때문에 재사용성과 생산성이 증가하게 된 것입니다.  
하지만 객체지향에도 단점이 존재합니다.  
절차지향보다 처리속도가 느리며, 객체들의 모든 역할과 기능들을 이해해야 하고, 서로간의 상호작용이 있을 경우에는 더욱 복잡해지기 때문에 개발속도가 느리며, 높은 난이도를 요합니다.

하지만 처리속도의 경우에는 하드웨어의 발전에 따라 점점 좁혀지고 있으며, 느린 개발 속도와 높은 난이도의 경우에는 결국 개발자의 역량에 따라 달라질 수 있습니다. 그리고 이러한 점들은 충분히 극복할 만한 단점입니다.

</br>

---

## **_객체지향은 왜 높은 난이도인가?_**

객체지향은 왜 높은 난이도를 단점으로 꼽았을까에 대해서 저의 주관적인 생각은 사람의 생각의 관점이라고 생각합니다.  
자판기에서 음료수를 뽑을 때 사람은

1. 돈을 넣는다.
2. 자판기에서 음료수를 선택한다.
3. 음료수가 나온다.

와 같이 동작의 순서에 대한 관점으로 이해하며, 받아들입니다.  
이 외에도, 선풍기를 해체나 조립을 할 때에나 음식의 요리과정, 수강신청을 하는 방법, 운동 등 살아오면서 동작을 중심으로 생각을 하고 동작을 행하는 주체를 사람이라고 생각합니다.

하지만 객체지향의 관점은 다릅니다.  
자판기에서 음료수를 뽑아먹는다는 것을 객체지향의 입장에서 바라본다면, 음료수를 뽑아먹는 "사람"이라는 객체와 음료수를 제공하는 "자판기"라는 객체, 심지어 "돈"과 "음료수들" 또한 객체로 정의를 할 수 있습니다.  
이러한 객체들은 각자들만의 동작을 행할 것입니다. 해당 동작들은 자신에 의해서 동작이 될수도, 다른 객체에 의해서 동작이 될수도 있는 것이죠.

그러니까 객체지향은 객체들의 속성과 행위들을 전부 이해하고 코드를 작성해야하는 것입니다.  
이러한 방식은 기존의 생각의 관점과는 다르기에 객체지향이 어려운 것이라고 생각됩니다.

</br>

---

## **_객체지향(OOP)의 특징 4가지_**

이제 이 어려운 객체지향이 가지는 특징들을 하나씩 살펴보겠습니다.

### **_상속_**

첫번재 특징은 상속입니다.  
 현실의 상속의 의미와 거의 유사하다고 보면 됩니다.  
 부모가 자식에게 유전자를 물려주듯, 또는 재산을 물려주듯 자바에서는 부모클래스와 자식클래스의 입장에서 자식클래스가 부모클래스의 특징과 기능등 모든 것을 물려받음을 통해 코드를 재사용하는 것입니다.

```java
class Car {
  private int wheel; //바퀴
  private int engine; //엔진
  ...이 외의 자동차 부품들 정의

  public void drive(){
    //자동차 운전 행위
  }
  ... 에어컨 켜기, 라이트 켜기 등의 자동차의 기본 동작들 정의
}

class K5 extends Car{
  //Car를 상속받음으로써 차의 기본 동작들을 물려받음
  //K5만의 특징과 기능들만을 추가로 정의해 놓으면 됨
}

class Avante extends Car{
    //Car를 상속받음으로써 차의 기본 동작들을 물려받음
  //아반떼만의 특징과 기능들만을 추가로 정의해 놓으면 됨
}
```

위와 같이 자동차라는 클래스를 정의해 놓았습니다. 그리고, 해당 자동차를 상속받는 K5와 아반떼 클래스를 정의해 놓았습니다.  
이러한 상속을 통해서 Car에서 정의해놓은 자동차의 기본 속성과 기능들은 그대로 물려주고, 자식클래스에서는 자신만의 속성과 기능들을 따로 정의해 놓으면 되기 때문에 Car의 코드의 중복을 피할 수 있습니다.

</br>

---

### **_다형성_**

클래스간의 상속관계나 클래스와 인터페이스 사이의 구현관계에서 실행시점에서 해당 객체의 형태가 정해져서 변수나 메서드가 해당 형태에 따라 동작방식이 정해지는 것을 **_다형성_** 이라고 합니다.

설명으로는 어려우니 아래의 예제를 통해 설명하겠습니다.

```java
public class TestEx {
    public static void main(String[] args) {
        Car car1 = new Car();
        car1.drive();

        Car car2 = new K5();
        car2.drive();

        Car car3 = new Avante();
        car3.drive();

    }
}
class Car {
    private int wheel; //바퀴
    private int engine; //엔진

    public void drive(){
        System.out.println("Car의 Drive 실행");
    }
}

class K5 extends Car{
    @Override
    public void drive(){
        System.out.println("K5의 Drive 실행");
    }
}

class Avante extends Car{
    @Override
    public void drive(){
        System.out.println("Avante의 Drive 실행");
    }
}

실행결과:
Car의 Drive 실행
K5의 Drive 실행
Avante의 Drive 실행
```

3개의 Car 타입을 참조하는 참조변수를 만들고 각각 Car, K5, Avante의 객체(인스턴스)를 만들어서 참조를 하게하여 drive 메서드를 동일하게 실행시켰습니다.

실행결과를 보면, 같은 참조변수지만 참조하는 객체의 **_형태_** 에 따라서 실행되는 메서드가 다르다는 것을 볼 수 있습니다.

```
부모의 참조변수에 자식의 객체를 담는 것을 "업캐스팅"이라고 하며, 형변환은 자동으로 이루어집니다.
반대로 업캐스팅된 참조변수를 원래의 자식참조변수에 담는것을 "다운캐스팅"이라고 하며, 다운캐스팅의 경우에는 형변환 명시가 필수입니다.

그리고 다형성의 핵심은 바로 "동적 바인딩"이며, 간단하게 말하면 업캐스팅된 상황에서 메서드의 실행방식은 자식의 오버라이딩된 메서드가 있을 때에는 자식의 메서드가 실행되고 아니면 부모의 메서드를 실행시키는 것입니다. 이를 통해 다형성이 동작이 되는 것입니다.
```

인터페이스와 클래스간의 구현관계에서도 다형성은 동작이 됩니다.

```java
package basic;

public class TestEx2 {
    public static void main(String[] args) {
//        Car car1 = new Car(); 인터페이스로는 객체 생성 불가!
//        car1.drive();

        Car car2 = new K5();
        car2.drive();

        Car car3 = new Avante();
        car3.drive();

    }
}
interface Car {
     //인터페이스에서는 상수만 정의가능!
     int WHEEL = 4; //바퀴
     int ENGINE = 1; //엔진

    //인터페이스에는 추상메서드, default 메서드 static 메서드만 정의 가능
    // 하지만 static은 오버라이딩 불가(static은 정적바인딩 즉 컴파일 시점에 이미 메모리에 로딩이 됨.)
    //오버라이딩은 동적바인딩 즉, 런타임 시점에 실행할 메서드가 정해지는데 이미 정적 바인딩이 된 메서드에는 오버라이딩 사용 불가
    default public void drive(){
        System.out.println("Car의 Drive 실행");
    }
}

class K5 implements Car{
    @Override
    public void drive(){
        System.out.println("K5의 Drive 실행");
    }
}

class Avante implements Car{
    @Override
    public void drive(){
        System.out.println("Avante의 Drive 실행");
    }
}

실행결과:
K5의 Drive 실행
Avante의 Drive 실행
```

인터페이스로 바꿈에 따라 자바의 문법에 맞지 않는 부분들이 변경되었지만, 핵심인 다형성에는 영향이 없습니다.

</br>

---

### **_추상화_**

추상화는

1. 불필요한 부분을 숨긴다.
2. 공통적인 특징(속성과 기능)을 분리한다.

라고 설명이 되어 있습니다. 자세한 설명은 예시를 통해 보겠습니다.

```java
package basic;

public class TestEx2 {
    public static void main(String[] args) {
//        Car car1 = new Car();
//        car1.drive();

        Car car2 = new K5();
        car2.drive();

        Car car3 = new Avante();
        car3.drive();

    }
}
interface Car {
     int WHEEL = 4; //바퀴
     int ENGINE = 1; //엔진

     public void drive();
     public void 에어컨켜기();
}

class K5 implements Car{
    @Override
    public void drive(){
        System.out.println("K5의 Drive 실행");
    }

    @Override
    public void 에어컨켜기() {
      //에어컨 키는 동작
    }
}

class Avante implements Car{
    @Override
    public void drive(){
        System.out.println("Avante의 Drive 실행");
    }
    @Override
    public void 에어컨켜기() {
      //에어컨 키는 동작
    }
}

```

모든 차는 운전기능, 에어컨키는 기능과 같은 기본적인 동작들을 할 수 있습니다. 모든 차 이기에 공통의 기능들을 인터페이스에 정의해놓고, 이를 구현시키는 클래스들에게 동작을 정의합니다.

사용자는 각각의 구현 클래스들을 인터페이스 타입으로 변경하여 사용하기 때문에 구현 클래스들의 구현부를 알지 못합니다. 그래서 위와 같이 구현하는 객체에 의존하지 않고 추상화가 되어있는 클래스나 인터페이스에 의존함으로써 구현된 코드를 숨깁니다.

</br>

---

### **_캡슐화_**

캡슐화는 필드들을 private으로 두고 해당 필드들의 접근하는 방식을 메서드에 정의함으로써, 데이터의 직접적인 접근을 막는것입니다.

```java
public class Person{
    private int age;
    private String name;

    public int getAge() {
        return age;
    }
    public void setAge(int age) {
        this.age= age;
    }

    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
}
```

위와 같이 set~ 과 get~ 의 메서드를 통해 필드에 접근할 뿐 직접적인 필드명을 통해서는 접근이 불가합니다.

보통 위와 같이 set~, get~을 setter와 getter라고 표현합니다.

현실에서의 간단한 예시로는 은행 계좌의 입,출금입니다.  
입금과 출금은 ATM기기 또는 은행원에 의해 돈이 간접적으로 관리가 이루어집니다. 각각의 사용자에게 해당 계좌의 직접적인 접근을 허용한다면, 보안에 엄청난 신경을 쓰지 않는 이상은 이를 악용하는 사례가 등장할 것입니다.

객체의 필드 또한 동일합니다. 메서드의 "행위"로만 접근해야 할 필드들을 직접적인 접근을 허용할 경우 외부에서 의도적이든 아니든 접근하는 목적을 알기가 어렵습니다. 하지만 메서드의 행위로만 제한하고 해당 행위를 정의한다면 목적을 쉽게 알 수 있습니다.

</br>

---

## **_다음으로는_**

이번에 객체지향의 4대 특징을 알아봤습니다.  
다음으로는 SOLID라고도 말하는 객체지향에 맞게 설계하기 위한 원칙 5가지입니다.

위의 특징들만 알고 쓴다고 해서는 객체지향으로 개발한다고 할 수 없습니다. 객체지향에 맞게 설계하고 개발하기 위해 지켜야 할 5가지 원칙들을 깊게 이해하고 이에 맞게 설계를 해야 합니다.
