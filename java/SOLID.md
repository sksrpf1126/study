# **_SOLID(객체지향 설계 원칙 5가지)_**

**_SOLID_** 란 좋은 객체지향을 설계하기 위해 지켜야 할 원칙 5가지를 정의해 놓은 것으로써, SRP, OCP, LSP, ISP, DIP 의 앞글자를 딴 것이다.

</br>

---

## **_SRP(Single Resposibility Principle)_**

SRP는 단일 책임 원칙이라고 한다.  
하나의 클래스에는 하나의 책임을 가져야 한다. 라고 하는데, 이 책임이라는 것이 모호하다. 하나의 책임이 클수도, 작을수도 있고 문맥이나 상황에 따라서도 각자 생각하는 책임이 달라질 수 있는 것이다. 결국 이러한 점은 많은 경험을 해보아야 한다.

그러면 어떻게 하면 단일 책임 원칙이 잘 지켜졌다고 볼 수 있나?  
중요한 기준은 **_변경_** 이다.  
변경이 있을 때 파급이 적으면 SRP를 잘 따른 것이다.  
예시로 A메서드를 호출하는데 내부적으로 B메서드를 호출하고, B메서드 내부에서도 C메서드를 호출하는 코드가 있는데, 이 때 A메서드를 수정을 해야 한다면?  
B메서드와 C메서드의 코드를 확인하며 A메서드의 수정에 따라 같이 변경해야할 부분이 있는지까지 신경을 써야 한다는 것이다.

결국 하나의 수정에 하나의 부분만 수정이 이루어진다면 어찌보면 SRP를 잘 지켰다고 볼 수 있다.

</br>

---

## **_OCP(Open-Close Principle)_**

OCP란 개방-폐쇄 원칙이라고 한다.  
확장에는 열려있으나, 변경에는 닫혀 있어야 한다라고 표현하기도 한다.  
기존의 코드를 변경하지 않으면서도 기능을 수정하거나 추가할 수 있도록 설계를 하라는 말이다.

말로만 보면 이해가 되지 않는다.

```java
public class MemberService {
   private final MemberRepository memberRepository = new MemoryMemberRepository();
   // private final MemberRepository memberRepository = new JdbcMemberRepository();

}
```

위의 코드를 보면 MemberService에 필드로 빈을 주입하고 있다.  
만약 MemoryMemberRepository에서 JdbcMemberRepository로 변경을 해야한다면 주석부분처럼 MemberService의 코드를 수정해야 하는 경우가 생겨버린다.

위에서 OCP를 지키기 위해서는 추상화와 다형성을 이용하면 OCP를 지킬 수 있게 된다.  
객체를 생성하고 의존관계를 맺어주는 별도의 설정자를 만들고, 추상화와 다형성을 활용하여 설정자를 통해 빈을 주입하도록 하면 된다.

```java
    private final MemberRepository memberRepository;

    @Autowired
    public MemberService(MemberRepository memberRepository){
        this.memberRepository = memberRepository;
    }
```

위와 같이 생성자 주입 방법을 통해 구현한다.  
그리고 설정자를 통해 원하는 구현체를 주입만 해주면 되는 것이다. 이후에 필요한 기능들은 해당 구현체에 구현을 해주면 되는 것이며, 새로운 구현체가 필요하면 그저 인터페이스를 구현하는 새로운 구현체를 생성하고 설정자만을 변경하면 되는 것이다.

</br>

---

## **_LSP(Liskov substitution principle)_**

LSP는 리스코프 치환 원칙이라고 한다.
정의로는 하위 타입의 객체는 상위 타입의 객체에서 가능한 행위를 수행할 수 있어야 한다. 즉, 상위 타입 객체를 하위 타입 객체로 변경하여도 문제 없이 정상적으로 동작해야 한다는 것이다.

이해를 돕기위해 도형을 예시를 들어보자.  
도형 클래스와 사각형 클래스가 있고, 사각형 클래스는 도형 클래스의 상속을 받는다고 가정하자.  
(1) 도형은 둘레를 가지고 있다.  
(2) 도형은 넓이를 가지고 있다.  
(3) 도형은 각을 가지고 있다.  
일반화 관계(일관성인지 확인하는 방법은 단어를 교체해 보면 알 수 있다.  
(1) ~ (3)의 도형이란 단어 대신 사각형을 넣어보자.  
(1) 사각형은 둘레를 가지고 있다.  
(2) 사각형은 넓이를 가지고 있다.  
(3) 사각형은 각을 가지고 있다.  
(1) ~ (3) 모두 딱히 이상한 부분이 보이지 않는다. 따라서 도형과 사각형 사이에는 일관성이 있다고 할 수 있다.여기서 원(Circle) 이라는 도형에 대해 생각해보자.   
원 클래스 역시 도형 클래스의 상속을 받는다고 가정하자. 앞에서 언급한 (1) ~ (3)의 도형 단어 대신 원을 대입해보자.  
(1) 원은 둘레를 가지고 있다.  
(2) 원은 넓이를 가지고 있다.  
(3) 원은 각을 가지고 있다.  
문장을 읽어보면 (3)번 문장이 어색하다는 것을 알 수 있다. 따라서 도형 클래스는 LSP을 만족하지 않은 설계라 할 수 있다. 따라서 (3)문장에 대해서는 일반화 관계가 성립하도록 수정되어야 한다.

출처: https://dev-momo.tistory.com/entry/SOLID-원칙 [Programming Note:티스토리]

위에 좋은 예시가 있어 그대로 가져왔다.

추가로 김영한님은 매우 간단하게 자동차 예시를 들었다.  
자동차 인터페이스가 있고 이를 구현하는 구현체들이 있을 때, 악셀이라는 기능을 구현한다고 하자.  
악셀을 밟으면 앞으로 가야한다는 정의를 해놓고, speed를 +10을 한다고 가정하자.  
근데 누군가 구현체에 악셀 기능을 speed를 -10이 되도록 구현을 해놓았다면? 인터페이스가 정의해놓은 규약을 어긴 것이다.  
이를 리스코프 치환 원칙을 위배했다고 말한다.

</br>

---

## **_ISP(Interface Segregation Principle)_**

ISP는 인터페이스 분리 원칙이라고 한다.  
범용적인 인터페이스 하나보다 세부적인 인터페이스 여러개가 낫다. 라고 말한다.  
예시를 들어보자.  
자동차 인터페이스가 있다. 그리고 구현체들은 당연히 자동차 모델들이다.  
하지만 자동차라는 것을 현실에서 생각해보면, 자동차를 운전하는 운전자도 있고, 자동차를 제조하는 제조자도 있고, 자동차를 정비하는 정비사도 있다.  
만약에 자동차를 제조하고 정비하는 게임을 만든다고 가정하면, 자동차라는 인터페이스 하나만을 두는 것이 옳은 방향일까?  
차라리 운전 인터페이스, 정비 인터페이스, 제조 인터페이스 등으로 세분화 시키면 정비 인터페이스가 수정이 되어도, 운전이나 제조의 인터페이스는 어떠한 영향이 가지 않을 것이며, 고려할 필요도 없는 것이다.

ISP를 지키면, 인터페이스가 명확해지고 대체 가능성이 높아진다.

</br>

---

## **_DIP(Dependency Inversion Principle)_**

DIP는 의존관계 역전 원칙이라고 한다.  
의존 관계를 맺을 때에는 변하기 쉬운 것(구체화) 보다는 변하기 어려운 것(추상화)에 의존해야 한다는 원칙이다.  
간단하게 말하면 구현 클래스 말고 인터페이스를 의존하라는 말이다.

위 코드를 예시로 말하면 MemberService입장에서는 Memory, Jdbc, Jpa의 레포지토리는 몰라야 하고, 오로지 해당 구현체들의 인터페이스만 알게끔 개발해야 한다는 것이다.

객체 세상에서는 인터페이스(추상화)를 의존해야 유연하게 변경할 수 있다. 구현 클래스(구체화)를 의존할 경우에는 프로젝트가 커지면 커질수록 변경이 매우 어려워진다고 한다.

```java
private final MemberRepository memberRepository = new MemoryMemberRepository();
```

위 코드는 MemberRepository도 의존하지만 new 를 통해 MemoryMemberRepository의 인스턴스를 생성하면서 결국 MemoryMemberRepository 또한 의존한다는 것이다. 즉 2개를 의존한다는 것이다.

</br>

---

# **_참고_**

- https://dev-momo.tistory.com/entry/SOLID-%EC%9B%90%EC%B9%99
- https://velog.io/@haero_kim/SOLID-%EC%9B%90%EC%B9%99-%EC%96%B4%EB%A0%B5%EC%A7%80-%EC%95%8A%EB%8B%A4
- 김영한님의 스프링 핵심 원리 - 기본편
