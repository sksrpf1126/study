# **_트랜잭션 격리수준_**

## **_트랜잭션 격리수준이란?_**

트랜잭션 격리수준(isolation level)이란 동시에 여러 트랜잭션이 처리가 될 때, 트랜잭션들끼리 얼마나 서로 고립(격리)가 되어 있는지를 나타내는 것이다.

격리수준은 아래와 같이 총 4개의 단계로 나뉜다.

1. READ UNCOMMITTED (커밋되지 않은 읽기)
2. READ COMMITTED (커밋된 읽기)
3. REPEATABLE READ (반복 가능한 읽기)
4. SERIALIZABLE (직렬화 가능)

1번에서 4번으로 내려갈수록 트랜잭션의 고립 정도가 높아지며, 자세한 내용은 아래에서 하나씩 알아보자.

</br>

---

## **_READ UNCOOMITTED_**

가장 낮은 격리수준으로써, 1번 트랜잭션에서 레코드를 변경하고 커밋을 하지 않아도, 2번 트랜잭션에서는 1번 트랜잭션에서 변경한 레코드를 조회해 온다.  
그래서 "커밋되지 않은 읽기" 라고 표현한다.

</br>

<p align = "center">
<img src="https://github.com/sksrpf1126/study/assets/62879192/0b8c956e-0438-45f1-b779-8103bffd9c9e" width = 70%>
</p>

위의 예시를 보면 1번 트랜잭션에서 '222'의 아이디를 가진 'Busan'을 추가하였고, 커밋을 하지 않은 상태이다.  
이때, 2번 트랜잭션에서 222를 조회한다면 정상적으로 레코드가 조회가 된다.

위와 같이 특정 트랜잭션이 아직 커밋되지 않은 상황에서 다른 트랜잭션이 해당 변경 사항을 조회할 수 있는 문제를 **_"Dirty Read"_** 라고 한다.

만약, 1번 트랜잭션이 데이터를 추가하기만 하고 rollback을 했는데, 2번 트랜잭션이 추가된 데이터를 읽어버린다면 2번 트랜잭션은 존재하지도 않는 데이터를 읽게되는 문제가 발생하기 때문에 해당 격리수준은 사용될 일이 없다.

</br>

---

## **_READ COMMITTED_**

해당 격리수준은 "커밋된 읽기"라고 표현하며, 그 이유는 트랜잭션이 커밋되어 반영된 데이터들만을 읽기 때문이다.  
이렇게 동작할 수 있는 이유는 특정 트랜잭션이 값을 변경하게 되면 Undo 영역이라는 곳에 변경되기 전의 레코드를 저장시키며, 다른 트랜잭션들에서는 변경시킨 트랜잭션이 커밋되기 전까지는 Undo 영역에 있는 레코드를 읽기 때문이다.

<p align = "center">
<img src="https://github.com/sksrpf1126/study/assets/62879192/7d164646-d455-45db-8856-d8d70e3c4e5f" width = 70%>
</p>

위의 예시를 보면, 1번 트랜잭션에서 '222'의 아이디의 Busan을 Jeju로 변경을 하고 커밋되지 않는 상태에서 2번 트랜잭션이 '222'의 동일한 아이디를 조회하면 Undo 영역에 있는 '222', 'Busan' 레코드를 조회하게 된다.

이후 1번 트랜잭션이 커밋이 되면 '222', 'Jeju' 값으로 변경이 되며, 이후 다른 트랜잭션에서 또 조회를 하게 되면 그때는 변경된 Jeju값을 조회하게 된다.

이를 통해 READ UNCOMMITTED에서 발생하는 "Dirty Read" 문제는 발생하지 않게 된다.

하지만, 다른 문제가 발생하게 되는데, **_"반복 불가능한 조회 (Non-Repeatable Read)"_** 라는 문제가 발생한다.

해당 문제는 같은 트랜잭션 내에서 동일한 데이터를 여러번 조회했을 때 다른 결과가 나오는 문제를 말한다.

위에서 2번 트랜잭션이 처음에 조회할 때에는 Undo 영역에서의 '222', 'Busan'을 조회해왔지만 이후 1번 트랜잭션이 커밋된 이후에 동일하게 조회를 하면 '222', 'Jeju'를 조회하게 되어 같은 트랜잭션 내에 같은 select쿼리로 조회를 했지만 다른 결과가 나오게 되어버린다.

</br>

---

## **_REPEATABLE READ_**

해당 격리수준은 "반복 가능한 읽기"라고 하며, 그 이유는 READ COMMITTED에서 발생되는 Non-Repeatable Read라는 반복 불가능한 조회가 해결되기 때문이다.

동작방식은, 트랜잭션마다 별도의 아이디를 부여하며, 해당 트랜잭션의 아이디보다 작은 트랜잭션 번호에서 변경한 것만 읽도록 한다. 더 정확히 말하면 해당 트랜잭션이 시작되기 전에 커밋된 내용에 대해서만 조회할 수 있도록 하는 격리수준이다.

<p align = "center">
<img src="https://github.com/sksrpf1126/study/assets/62879192/660c1220-fc1e-49c4-926f-8b43bf06c301" width = 70%>
</p>

2번 트랜잭션의 아이디는 10이며, 1번 트랜잭션의 아이디는 12이다.  
1번 트랜잭션에서 '222'의 'Busan'의 값을 Jeju로 변경하고 커및을 한다. 이때, 변경되기 전의 데이터를 undo 영역에 값을 저장해둔다. 이후 2번 트랜잭션에서 다시 조회를 하여도 변경된 레코드는 12번의 트랜잭션 아이디이기 때문에 실제 레코드가 아닌 Undo영역의 바꾸기 이전의 데이터를 조회해 온다.

하지만 해당 격리수준도 해결하지 못하는 문제가 있다.  
**_"Phantom(팬텀) Read"_** 라고, 하며 첫 번째 쿼리에서는 없던 유령 레코드가 두 번째 쿼리에서는 나타나는 현상을 말한다.

```sql
START TRANSACTION; -- transaction id : 1
SELECT * FROM Member; -- 0건 조회

    START TRANSACTION; -- transaction id : 2
    INSERT INTO MEMBER VALUES(1,'joont',28);
    COMMIT;

SELECT * FROM Member; -- 여전히 0건 조회
UPDATE Member SET name = 'zion.t' WHERE id = 1; -- 1 row(s) affected
SELECT * FROM Member; -- 1건 조회
COMMIT;
```

위와 같은 쿼리가 있다고 하자.

1번 트랜잭션의 경우 처음 조회할 때는 0건인 상태이며, 이후 2번 트랜잭션에서 새로운 데이터를 넣고서 커밋을 한다.  
다시 1번 트랜잭션에서 동일한 쿼리로 조회를 해보면, 동일한 0건이지만 이후 update문으로 유령 레코드의 아이디를 업데이트 시키는 쿼리를 발생시키고 조회를 해보면 1건의 데이터가 생겨버린다.

이러한 데이터 부정합 문제가 발생하는 이유는, 일반적으로 update 쿼리가 발생되면 해당 레코드에 베타락을 걸고 갱신작업을 거친다. 그런데 베타락은 Undo 영역에는 락을 걸 수가 없고 실제 레코드에만 락을 걸수가 있다. 즉, 자신보다 큰 트랜잭션 아이디에서 삽입한 레코드여서 조회를 하면 안되지만 베타락에 의해서 실제 레코드에 접근하게 되고, 이를 갱신하고 나서는 1번 트랜잭션에서 삽입한 레코드는 아니지만 갱신한 레코드가 되기 때문에 0건이 아닌 1건의 데이터가 조회가 되는 것이다.

</br>

---

## **_SERIALIZABLE_**

가장 엄격한 격리 수준이며, 해당 수준으로 격리 수준을 설정해두면, 데이터를 조회하는 것 조차 공유 락을 획득해야만 한다. 공유락은 여러개가 걸릴 수 있기 때문에 데이터를 조회하는 행동으로는 여러 트랜잭션이 동시에 접근이 가능하지만 베타 락이 걸리는 순간 어떠한 트랜잭션도 해당 레코드에 공유 락을 걸수가 없다.

```
참고로, 2개의 공유 락이 걸린 상태에서 베타락을 걸려고하면 데드락이 발생한다.
그 이유는 베타락이 걸리기 위해서는 자신이 건 공유락을 제외하고 다른 공유락이 존재한다면 베타락을 걸 수가 없는데, 서로서로 베타락을 걸려고 상대방의 공유락이 해체되기만을 기다리기 때문에 데드락이 발생한다.
```

이러한 격리 수준은 보통 동시성에서 문제가 발생되는 경우를 해결하기 위해서 사용되며, 일반적으로는 해당 격리 수준을 사용하지 않는다. 이유는 동싵처리 능력이 떨어지기 때문에 성능이 좋지 않다. (하나의 갱신작업이 끝날 때 까지 이후의 트랜잭션은 대기를 하게 되므로)

</br>

---

## **_참고_**

https://medium.com/@sunnkis/database-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98%EC%9D%98-%EA%B2%A9%EB%A6%AC-%EC%88%98%EC%A4%80%EC%9D%B4%EB%9E%80-10224b7b7c0e  
https://joont92.github.io/db/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98-%EA%B2%A9%EB%A6%AC-%EC%88%98%EC%A4%80-isolation-level/
