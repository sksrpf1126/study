# **_반복문_**

해당 내용은 [SQL 레벨업](http://www.yes24.com/Product/Goods/24089836) 책을 통해 공부한 내용입니다.

쿼리문에 의한 결과 테이블은 쿼리문만을 보고 예상하고, 예상이 안되는 건 다시 직접 실행

ch5는 MySql문법을 기준

---

SQL에서 반복문에 대한 장단점과 반복문을 대체할 수 있는 방법을 설명한다.

---

## **_SQL에서의 반복문?_**

실제로 SQL에서는 반복문을 지원하지 않는다.

절차지향적인 사고에서 집합지향적인 사고로 바꿔야 하는 이유중 하나가 바로 반복문을 지원하지 않기 때문이다.

그런데 보통 절차지향적인 사고로 여러 프로그래밍 언어들을 배운다. 그렇기에 집합의 개념으로 SQL을 다루는 것은 기존의 사고에서 벗어나야 하며, 이는 매우 어렵다.

그렇기에 개발자들은 무의식적으로 절차지향적으로 쿼리문을 작성하고, 이를 해결하기 위한 PL/SQL 코드를 활용하여 절차지향적으로 코드를 작성한다. (대표적으로 프로시저가 존재)  
당연히 PL/SQL은 반복문 또한 제공해준다. 그렇기에 절차지향적으로 SQL 쿼리를 사용할 수 있게 된 것이다.

해당 책에서는 반복문을 사용해 해결하는 쿼리를 "반복계", 순수 SQL 쿼리만을 사용하는 쿼리를 "포장계" 라고 표현한다.  
</br>

---

## **_반복문 장단점_**

</br>

### **_장점_**

첫번째. 순수 쿼리문은 단순하게 작성하고 이를 PL/SQL 문과 반복문을 통해 SQL문을 잘 몰라도 쉽게 작성이 가능하다. 쿼리문이 단순하기 때문에 실행 계획 또한 변동 위험이 거의 존재하지 않기 때문에 실행 계획이 바뀌어버려서 성능이 저하가 된다거나 하는 문제가 발생하지 않는다.

반대로 얘기하면 순수 쿼리문만을 사용하는 "포장계"에서는 실행 계획에 대한 변동 가능성이 크다는 것이 단점이 된다.

두번째. 트랜잭션 제어가 편하다는 것이다.  
반복계는 여러 번 반복되는 경우 중간마다 커밋을 하게 한다면, 문제가 발생하는 경우와 같이 중단되는 경우에 해당 커밋을 기점으로 다시 시작하면 된다.  
반대로 포장계는 처음부터 다시 쿼리를 수행해야 한다.

</br>

### **_단점_**

첫번째. SQL 실행의 오버헤드가 발생한다. 반복계에서는 내부적으로 쿼리문도 반복하게 된다. 파서와 옵티마이저는 쿼리문을 실행해야 할 때마다 작동하게 되는데, 반복문으로 쿼리문을 반복시키면 결국 같은 쿼리문인데도 불구하고, 계속 파서와 옵티마이저가 동작하게 된다.

그렇기에 반복의 횟수가 증가하면 할수록 성능이 악화가 된다.

두번째. 데이터베이스의 진화에 대한 혜택을 받지 못한다.  
무슨 의미냐면 아직 현재 DBMS는 옵티마이저가 최적의 실행 계획만을 세우지 않는다. 그렇기에 DBMS 벤더는 순수 SQL문을 어떻게 하면 더 빠르게 더 효율적이게 실행시킬 수 있을까 고민하며 계속 발전을 하고자 한다는 것이다.

하지만 반복계는 이러한 혜택과는 전혀 상관이 없다는 것이다.

### **_트레이드 오프_**

그렇다고 반복문을 무조건 쓰지 말라는 것은 아니다. 위와 같은 장단점들을 잘 따져서 현재 적용해야할 모델에 무엇이 적합할지 판단하여 트레이드 오프를 하라는 것이다.

</br>

---

## **_순수 SQL에서 반복문 역할을 어떻게?_**

반복문의 행위가 필요할 때 순수 SQL에서는 이를 어떻게 해결해야 할까?

바로 **_"CASE식과 윈도우 함수"_** 를 활용하면 해결할 수 있다.

162페이지의 예제에서 sales테이블에서 이전 데이터와 현재 데이터를 비교하여 값의 차이에 따라 var이라는 필드에 상태를 기록하고, 필드가 추가된 sales2 테이블에 데이터를 삽입해야 한다.

위 문제를 반복문으로 해결할려면 레코드의 끝까지 반복문을 돌리면서 이전데이터와 현재데이터를 계속 비교하면서 상태를 반환할 것이다.

이를 case와 윈도우 함수로 구현해보면

```sql
insert into sales2
select company, year, sale,
case sign(sale - max(sale) over(
  partition by company
  order by year
  rows between 1 preceding and 1 preceding
) --over함수 끝
)--sign함수 끝
when 0 then '='
when 1 then '+'
when -1 then '-'
else null end as var
from sales;
```

case문에 처음의 when을 호출하기 전 식이 존재한다면 if - else문이 아닌 switch-case문처럼 동작하게 된다.

sign 함수의 경우에는 내부 식의 값이 양수면 1을 0이라면 0을 음수라면 -1을 반환하는 함수이다.

우선 over내부의 식에서 company를 기준으로 데이터를 자르고, 잘라서 나눠진 그룹들간에 year(연도)로 오름차순으로 정렬시킨다.

다음으로 rows between ~ 옵션을 추가해주었는데, 1 ~ 1 의 의미는 현재 레코드를 기준으로 1개 이전 부터 1개 이전 까지의 레코드 범위를 의미한다. 만약 2개 전 레코드를 기준으로 잡고 싶다면 row between 2 preceding and 2 preceding 으로 작성하면 된다.

자세한 동작은 https://tiboy.tistory.com/570 참고

이렇게 case와 윈도우 함수를 통해 반복문의 기능을 수행할 수 있다.

### **_EXISTS구문_**

책에서 EXISTS 구문을 통해 해결하는 예제를 설명하기 전에 EXISTS가 어떻게 동작하는지를 보자.

```sql
select * from postalhistory2;
```

위 sql문으로 조회해보면 아래의 테이블 구조를 확인할 수 있다.

  <p align = "center">
  <img src="https://user-images.githubusercontent.com/62879192/209802272-44e2be8f-d70c-49b1-9c48-11de1dde7287.png" width = 50%>
  </p>

위 테이블을 가지고 exists 구문의 동작을 이해해보자.

우선 exists는 서브쿼리와 함께 동작하게 되며, exists구문에 의해 반환 데이터가 하나라도 존재하면 true값 (1값)을 반환하며, 서브쿼리의 조건을 가지고 메인 쿼리의 테이블과 비교한다.

쉽게 말해서 메인 쿼리에서 a레코드, b레코드, c레코드 3개의 행이 존재하고, exists의 서브쿼리가 존재한다면 레코드마다 서브쿼리의 조건 구문을 실행하여 해당 조건을 하나라도 만족하는 순간 종료하고 메인쿼리의 레코드를 반환한다.

예제를 통해 어떻게 동작되는지 확인해보자.

```sql
select name, pcode
from postalhistory2 ph1
where name = 'A' and
exists
(
select *
from postalhistory2 ph2
where ph2.name = 'A' and ph1.lft > ph2.lft
);
```

where절에 exists 구문이 있으며, 괄호안은 서브쿼리이다.

우선 메인쿼리의 exists구문이 실행되기 전까지 ph1테이블 구조는 where절의 name = 'A'에 의해서 아래와 같은 테이블 구조가 된다.

  <p align = "center">
  <img src="https://user-images.githubusercontent.com/62879192/209804530-889a8d8f-f404-45e9-aef1-939966551c84.png" width = 50%>
  </p>

총 3개의 레코드가 존재한다.

exists는 이제 ph1테이블의 해당 레코드마다 서브쿼리를 수행하며, 서브쿼리의 레코드 수만큼 반복하여 서브쿼리의 결과가 단 하나라도 존재한다면 참을 반환하고, ph1테이블의 해당 레코드를 반환할 것이다.

우선 첫번째 레코드인 'A', '4130001', 0, 27을 대상으로 서브쿼리를 수행한다.  
서브쿼리를 보면 조건식의 ph2.name = 'A' 에 의해서 ph2테이블 구조도 위와 동일한 구조로 나오고 다음 조건으로 ph1.lft > ph2.lft를 수행하는데, 이때 메인쿼리의 첫번째 레코드를 대상으로 서브쿼리를 수행중이니 ph1.lft값은 0일 것이다.  
다음으로 ph2.lft는 nmae='A'까지의 조건을 수행한 테이블의 레코드 수만큼 반복하여 수행한다.

그럼 0(ph1 1번째 레코드) > 0(ph2 1번째 레코드)  
 0(ph1 1번째 레코드) > 9(ph2 2번째 레코드)  
 0(ph1 1번째 레코드) > 12(ph2 3번째 레코드)

만족하는 경우가 존재할 때까지 수행하는데, 전부 수행할 때까지 수행이 이루어지지 않았으므로 메인쿼리의 첫번째 레코드는 false 즉, 반환대상이 아니게 된다.

이후 두번째 메인쿼리의 두번째 레코드의 lft 값은 9이므로

9(ph1 1번째 레코드) > 0(ph2 1번째 레코드) 만족  
 9(ph1 2번째 레코드) > 9(ph2 2번째 레코드) 수행X  
 9(ph1 3번째 레코드) > 12(ph2 3번째 레코드) 수행X

첫번째 조건부터 만족하므로, 바로 수행을 종료하고 메인쿼리의 두번째 레코드를 반환한다.

마지막 레코드 또한 동일하게 동작하게 되고 그럼 쿼리문의 결과는

   <p align = "center">
  <img src="https://user-images.githubusercontent.com/62879192/209805775-524dc86a-9965-471a-b705-c6230bcf7be2.png" width = 50%>
  </p>

위와같이 메인쿼리의 두번째, 세번째의 name과 pcode만을 반환하게 된다.

### **_NOT EXISTS_**

exists는 조건에 맞는 레코드가 하나라도 존재할 때까지 수행을 하며, 하나라도 맞을 시에는 메인쿼리의 레코드를 반환한다.

not 을 붙이면 반대로 조건에 맞는 레코드가 단 하나라도 존재한다면 false를 반환하고 해당 레코드 또한 반환하지 않는다.

둘은 연산에서도 차이가 나타나는데, 위 예제를 다시보자.

첫번째 경우에는 exists는 만족하는 조건 단 하나도 찾지 못하였어서 3번 연산 끝에 false를 반환하였다.  
not exists는 만족하는 조건이 단 하나도 존재하지 않았기에 3번 연산 끝에 true를 반환한다.

두번째 경우에는 exists는 첫번째 부터 조건을 만족하기 때문에 바로 true를 반환하지만 not exists는 만족하는 조건이 존재하기 때문에 false를 반환한다.

즉, exists는 "조건에 하나라도 만족하면 참을 반환"하며, not exists는 "조건에 하나라도 만족하면 거짓을 반환" 한다.

exists는 2개의 레코드를 반환하였지만 not exists로만 바꿔버리면 첫번째 레코드 단 하나만을 반환하며 책의 예제는 not exists로 단 하나의 레코드를 반환하는게 목적이다. (196pg)

참고 : https://etloveguitar.tistory.com/124
