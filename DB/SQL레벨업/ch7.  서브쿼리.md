# **_서브쿼리_**

해당 내용은 [SQL 레벨업](http://www.yes24.com/Product/Goods/24089836) 책을 통해 공부한 내용입니다.

쿼리문에 의한 결과 테이블은 쿼리문만을 보고 예상하고, 예상이 안되는 건 다시 직접 실행

ch7은 MySql문법을 기준

---

서브 쿼리를 select절에 사용하면 스칼라 서브쿼리라 하고, from절에 사용하면 인라인 뷰라고 하고, where절에 사용하면 서브쿼리(중첩 서브쿼리) 라고 부른다.

서브쿼리를 통틀어서 말할 때는 select구문 안에 select 구문이 들어있는 것으로 표현한다.  
해당 책은 방금 말한 서브쿼리의 개념으로 서브쿼리의 성능과 언제 사용해야 좋을지를 설명한다.

---

## **_서브쿼리의 문제점_**

메인쿼리 (select쿼리 하나만 존재하는 경우)가 동작되는 방식이, 기존의 테이블에서 여러 식(조건, 정렬 등)을 통해 하나의 결과테이블을 도출해낸다.

서브쿼리(괄호로 묶어서 정의) 또한 서브쿼리자체만을 따지고 보면 메인쿼리와 동일하게 기존의 테이블로부터 결과테이블이 도출이 된다.

하지만 서브쿼리는 결과테이블이 메인쿼리의 하나의 식에 필요한 연산데이터로 사용이 된다는 것이다.

예시로 where절에 서브쿼리가 존재한다면 레코드가 해당 식에 맞는지 아닌지를 판단할 때마다 서브쿼리 즉, select구문이 실행이 된다는 것이다.  
메인쿼리의 연산에 필요한 데이터를 그때마다 select구문으로 만들어질 뿐 사용이 끝나면 없어지는 즉, **_"실체적인 데이터"_** 를 가지지 않는다는 것이다.

다음으로, 서브쿼리는 위에서 말했듯이 접근할 때 연산을 필요로 한다. (데이터를 도출해야 하기 때문)  
연산이 필요하다는 것은 메모리 공간을 사용한다는 것이고, 만약 메모리 공간이 부족하다면 저장소 공간을 사용하는 temp 탈락 현상이 발생할 수 있다.

마지막으로, 서브쿼리로부터 만들어지는 결과 데이터에는 구조적으로는 테이블과 차이가 없지만, 이미 기존의 테이블로부터 한번 연산을 통해 만들어졌기 때문에 명시적 제약이나 인덱스와 같은 메타 정보를 가지고 있지 않다. (서브쿼리 내에서 결과 데이터를 만들 때에는 기존의 테이블의 메타 정보를 활용(?))

정리를 하면 아래와 같다.

1. 연산 비용 증가 (추가적인 select구문에 의해)
2. 데이터 I/O 비용 발생(연산에 필요한 메모리 or 저장소 공간과 temp탈락)
3. 최적화를 받을 수 없음(서브쿼리의 결과데이터에는 메타정보가 없기 때문)

</br>

### **_서브쿼리 대책_**

책에서는 윈도우함수와 case식을 통해서 해결하였으며, 보통 서브쿼리로밖에 해결할 수 있는 문제는 많이 존재하지 않는다.  
윈도우 함수, case식 이외에 조인으로도 해결이 가능하다.

</br>

---

## **_서브쿼리 사용이 더 나은 경우_**

더 나은 경우는 바로 결합과 집약의 순서에 따라 나타난다.  
결합(조인)할 때에 레코드 히트율 즉, 결합 대상이 많아지면 많아질수록 많은 연산을 필요로 하게 된다. 그래서 결합하고 집약의 순서를 반대로 하여 우선 집약을 한 후 결합을 시키는 것이다.  
이러면 결합 대상이 적어지기 때문에 성능이 좋아질 수가 있다.

단, 이러면 결합 -> 집약 보다 집약 -> 결합이 집약 비용이 더 높아지며, 트레이드 오프가 발생한다.  
또한, 환경도 고려해야하는데, 하드웨어, 미들웨어, 결합 시 선택되는 알고리즘 등을 고려해야 한다.  
즉, 실제로 실행 계획과 성능을 보면서 무엇이 좋을지 비교해야 한다.
