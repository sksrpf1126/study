# **_결합_**

해당 내용은 [SQL 레벨업](http://www.yes24.com/Product/Goods/24089836) 책을 통해 공부한 내용입니다.

쿼리문에 의한 결과 테이블은 쿼리문만을 보고 예상하고, 예상이 안되는 건 다시 직접 실행

ch6은 MySql문법을 기준

---

챕터6은 결합(join)과 관려된 내용을 설명한다.

결합의 종류와 대표적인 결합들의 동작들의 설명, 그리고 결합마다 적용되는 알고리즘에 따라 달라지는 성능을 설명한다.

---

## **_결합 종류_**

결합의 종류에는

1. 크로스 결합
2. 내부 결합
3. 외부 결합
4. 자기 결합
5. 등가/비등가 결합
6. 자연 결합  
   의 여러가지 결합이 존재한다.

자연결합의 경우에는 내부 결합이면서 등가 결합이라고 표현하는데, 쉽게 아래 쿼리가 자연결합이라고 보면 된다.

```sql
select *
from employees E inner join department D
on E.dept_id = D.dept_id;

-- 위 쿼리와 동일
select * from employees natural join department;
```

보통은 그냥 첫번째 쿼리를 사용한다.

결합의 기본 동작들은 아래의 글들을 참고하자.  
https://velog.io/@yanghl98/Database-JOIN  
https://sparkdia.tistory.com/17

### **_크로스 결합_**

크로스 결합은 예시로 테이블 A에 a1,a2,a3 레코드가 존재하고 테이블 B에 b1,b2,b3 레코드가 존재하는 경우

(a1,b1) (a1,b2) (a1,b3) ..... (a3,b1) (a3, b2) (a3, b3) 총 9개의 결과가 나오는 결합이다.

크로스 결합은 실무에서는 사용할 일이 거의 없다고 봐도 무방하다고 한다. 그 이유는 위 데이터 형식이 필요한 경우가 없기도 하고 연산과정을 간단하게 보기만 해도 그렇듯 많은 연산을 필요로 하여 성능이 저하가 되는 결합이다.

그래서 의도한 것이 아니라면 크로스 결합의 사용을 지양해야 하는데, 가끔 의도치 않게 크로스 결합이 사용이 되는 경우가 존재한다.

아래의 쿼리가 그 에시이다.

```sql
select *
from tableA, tableB;
```

두 테이블을 조회하는데, 어떠한 결합을 사용할지, 결합 조건은 무엇인지 적혀있지 않다.  
이러한 경우 DBMS는 어떻게 할지 모르기 때문에 크로스 결합 방식을 사용하게 되어버린다.

그러니 의도한 것이 아니라면 반드시 결합 조건을 까먹지 말자. (테이블 3개 이상으로 결합하는 경우 조심)

</br>

### **_외부 결합에서의 ON과 WHERE_**

결합 조건을 on으로만 사용하는 경우, on과 where을 둘 다 사용하는 경우 where만 사용하는 경우가 존재한다. (INNER JOIN, OUTER LEFT JOIN 등 조인을 사용할 것이라는 구문이 있다면 on절은 필수인듯 하다.)

무슨 차이일까? 쿼리문과 그에대한 결과를 우선 보자.

```sql
select *
from ch6_employees e left join department d
on e.dept_id = d.dept_id;
```

  <p align = "center">
  <img src="https://user-images.githubusercontent.com/62879192/209945327-5d2aea90-0a2d-4e3b-b1c0-3decbfdbdc3b.png" width = 50%>
  </p>

우선 그냥 left join했을 때의 결과이다.  
 왼쪽 테이블의 dept_id가 오른쪽 테이블에 존재한다면 해당 레코드를 반환하며 오른쪽 테이블에 같은 dept_id가 존재한다면 크로스 결합처럼 여러개의 레코드가 반환된다.

```sql
select *
from ch6_employees e left join department d
on e.dept_id = d.dept_id and e.dept_id = 10;
```

  <p align = "center">
  <img src="https://user-images.githubusercontent.com/62879192/209945330-edfa02d4-5a4c-4c35-9e18-499e9f03bbe3.png" width = 50%>
  </p>

on절에 and 조건으로 e.dept_id = 10을 줬을 때 보여지는 데이터이다.

왼쪽 테이블의 dept_id가 10일 때 오른쪽 테이블에서 자신의 dept_id가 왼쪽 테이블의 dept_id와 동일하며 자신의 dept_id 가 10인 경우에는 결과값을 반환하며 조인한다.

반대로 11~12까지의 dept_id인 경우에는 dept_id = 10이 될 수가 없어 null로 반환하며 조인한다.

즉, on 절은 조인의 조건을 나열하는 것이다.

```sql
select *
from ch6_employees e left join department d
on e.dept_id = d.dept_id
where and e.dept_id = 10;
```

  <p align = "center">
  <img src="https://user-images.githubusercontent.com/62879192/209945332-cd5ab4df-3049-443e-a186-1655da65fe4c.png" width = 50%>
  </p>

and dpet-id = 10을 where 조건으로 이동시킨 후 실행한 결과이다.  
위는 우선 **_같은 dept-id로 조인을 한 후_** 그다음으로 조인되서 반환된 데이터들 중에 dept_id 가 10인 데이터만 반환해서 보여주는 것이다.

위 처럼 동작하는 이유는 from - on - where 순으로 구문이 동작하기 때문이다.  
위 차이를 이해하면서 outer join(외부 결합)을 사용해야 한다.

outer join인 경우에만 위처럼 동작하니 다른 결합은 신경안써도 된다.

참고  
https://myjamong.tistory.com/229  
https://blog.leocat.kr/notes/2017/07/28/sql-join-on-vs-where

</br>

---

## **_결합 알고리즘과 성능_**

옵티마이저가 결합할 때 선택되는 알고리즘에는 크게 총 3가지가 존재한다.

1. Nested Loops
2. Hash
3. Sort Merge

MYSQL의 경우에는 Nested Loops와 그에 파생되는 알고리즘만 존재하고 사용하며, Hash와 Sort Merge는 존재하지 않는다. 이렇게 DBMS에 따라 변할 수 있지만 보통은 위 3개를 지원한다.

</br>

### **_Nested Loops_**

이름 그대로 중첩 반복을 사용하는 알고리즘이다.  
결합할 때 앞에오는 테이블을 구동 테이블(외부 테이블), 뒤에 오는 테이블을 내부 테이블이라고 부르는데, 예를 들어 구동 테이블의 레코드가 4개고, 내부 테이블의 레코드가 5개이면 4 X 5 , 총 20번의 반복을 통해 결합 조건에 맞는 레코드를 찾는다.

해당 알고리즘의 특징은 구동 테이블(외부 테이블)의 레코드가 적으면 적을수록 성능이 좋아진다고 한다.  
그런데 위 말에는 의문이 생긴다. 외부 테이블과 내부 테이블의 레코드가 변경되어도 5 X 4 로 결국 총 20번의 반복을 수행하는 것이 아닌가?

위 말에는 전제조건이 하나가 있다.  
바로 내부 테이블의 결합키에 인덱스가 적용되어 있는 경우이다.  
인덱스가 적용이 되어 있다면 반복을 생략할 수 있기에, 구동 테이블의 레코드 수가 적을수록 성능이 향상되는 것이다.

그래서 보통 해당 알고리즘을 사용하는 SQL 구문을 튜닝하는 경우에는

```
1. 구동 테이블은 작은 것으로
2. 내부 테이블에는 인덱스를 적용
```

과 같은 방법으로 튜닝을 하는게 SQL 튜닝의 가장 기본적인 방법이다.

</br>

### **_Nested Loops의 단점_**

만약에 내부 테이블의 결합키가 유일하지 않는다면? 즉 레코드 히트율이 높다면 인덱스가 적용이 되어 있다고 해도 결국 내부적으로 반복을 수행하여 결합 조건에 맞는 여러 레코드들을 찾을 것이다.

거기다가 만약 조건마다 레코드 히트율이 전부 달라서 어떤 결합조건에 따라 수행해야 하는 레코드 수가 10만개, 어떤 레코드는 100만개가 존재한다면 매개변수의 조건에 따라 성능이 달라지는 형상이 발생한다.

그렇기에 성능이 다시 악화가 되는 상황이 발생하는데, 이럴 경우 2가지 방법으로 해결을 한다.

1. 내부 테이블과 구동 테이블을 변경하여 결합
2. Hash 결합 알고리즘 사용

1번의 경우 둘의 위치가 변경되기에 이제는 내부 테이블의 결합키가 유일해진다. 그래서 1 대 1 로 접근이 가능해져서 성능 비균등 문제를 해결할 수 있다.

2번은 Hash 결합 알고리즘 내용에서 보도록 하자.

</br>

### **_Hash_**

Hash 결합 알고리즘은 Hash를 사용하는 것이다.  
보통 작은 테이블과 큰 테이블로 기준을 나누어서, 작은 테이블의 결합키에 Hash 알고리즘을 사용하여 Hash값을 저장하는 해쉬 테이블을 만들고 저장한다.  
이후 해당 해쉬 테이블을 가지고 큰 테이블과 결합을 맺도록 하는 방식이다.

그런데 Hash를 사용하면 워킹 메모리 공간을 사용하게 된다. 즉, Nested Loops 보다 추가적으로 메모리를 사용한다는 것이며, 워킹 메모리 공간이 부족한 경우 저장소를 사용하게 되는 "temp 탈락"이 발생하기 때문에 "temp 탈락" 에 의해 성능이 약하되는 경우가 존재할 수 있으므로 주의해야 한다.

다음으로 출력되는 해쉬값은 레코드의 결합키를 입력값으로 사용을 하는데, 이 때 입력값의 순서가 정해진 것이 아니기 때문에 등치 결합에서만 사용할 수 있다.

이러한 Hash는 그럼 언제 사용해야 하는가?

### **_Hash가 유용한 경우_**

바로 Nested Loops의 차선책으로 사용하는 경우이다.

차선책으로 사용되는 경우는 아래와 같다.

1. 적합한 구동 테이블(상대적으로 작은 테이블)이 존재하지 않는 경우
2. 앞서 본 것처럼 내부 테이블의 레코드 히트율이 높은 경우
3. 내부 테이블에 인덱스가 적용 하지 않는(적용을 못하는) 경우

Hash 알고리즘은 양 테이블을 풀스캔 하므로, 테이블 규모가 너무 큰 경우에는 오히려 Nested Loops가 더 나을 수 있다.

</br>

### **_Sort Merge_**

앞 2개의 결합 알고리즘보다 상대적으로 덜 중요한 결합 알고리즘이다. 그 이유는 고려해야 할 것이 많기 때문이다.

우선 해당 알고리즘은 양쪽테이블을 스캔 후에 정렬을 한다.  
이후, 정렬된 양쪽 테이블로 결합을 맺는다.

정렬이 되어 있기 때문에 결합을 하는데에 성능이 향상이 될 수가 있지만, 정렬을 하는데에도 워킹 메모리 공간을 사용하게 되고, 무엇보다 Hash는 작은 테이블만을 기준으로 사용하지만, 해당 알고리즘은 양쪽 테이블에 대해서 정렬해야 하기 때문에 보다 많은 메모리 공간을 사용하게 된다.

즉, temp 탈락 가능성이 더 높은 것이다.

원리적으로 테이블 자체가 이미 정렬이 되어 있다면 해당 알고리즘을 사용하는 것을 고려해볼만 하다. 그렇기 위해서는 SQL에서 테이블에 있는 레코드들의 물리적인 위치를 알고 있을 때만 가능하기 때문에 의존적이라는 성질이 나타난다.

</br>

### **_결합 알고리즘 정리_**

간단하게 정리하면, 기본적으로는 Nested Loops를 사용하되, Hash 알고리즘으로 사용해야 하는 경우에는 Hash를 사용하자.

</br>

---

## **_의도하지 않은 크로스 결합_**

맨 앞에서 결합 조건을 명시하지 않으면 크로스 결합이 발생한다고 하였다.  
보통 2개의 테이블에서는 발생하지 않는데, 3개의 테이블간에 결합을 할 때 발생한다.

```sql
select *
from table_a as A inner join table_b as B
on A.col_a = B.col_b
inner join table_c as C
on A.col.a = C.col.c
```

위에는 A는 B와 C를 기준으로 결합이 진행되었지만 B와 C 사이에는 어떠한 결합 조건도 명시되지 않았다.

이러한 경우 무조건 크로스 결합이 발생하지는 않는다.

```
Table A를 구동 테이블로 Table B와 결합하고 그 결과를 Table C와 결합
Table A를 구동 테이블로 Table C와 결합하고 그 결과를 Table B와 결합
Table B를 구동 테이블로 Table A와 결합하고 그 결과를 Table C와 결합
Table C를 구동 테이블로 Table A와 결합하고 그 결과를 Table B와 결합
```

즉, B와 C가 먼저 결합되지만 않는다면 크로스 결합은 발생하지 않는다.  
하지만 B와 C가 먼저 결합되는 경우에는 어떠한 결합조건도 존재하지 않기 때문에 내부적으로 크로스 결합을 시행해버리기 떄문에 문제가 발생한다.  
보통, 옵티마이저가 B와 C가 테이블 크기가 작아서 우선적으로 작은 테이블끼리 결합을 맺는 실행 계획을 세웠을 때 발생한다.

이를 해결하기 위해서는 아래와 같이 불필요한 결합 조건을 추가해주면 된다.

```sql
select *
from table_a as A inner join table_b as B
on A.col_a = B.col_b
inner join table_c as C
on A.col.a = C.col.c
and B.col.b = C.col.C
```

단, B와 C 테이블 간에 결합조건으로 사용할 수 있는 필드가 존재해야 하며, 원하는 결과에 영향을 주지 않아야 한다.
