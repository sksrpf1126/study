# **_인덱스_**

해당 내용은 [SQL 레벨업](http://www.yes24.com/Product/Goods/24089836) 책을 통해 공부한 내용입니다.

쿼리문에 의한 결과 테이블은 쿼리문만을 보고 예상하고, 예상이 안되는 건 다시 직접 실행

ch5는 MySql문법을 기준

</br>

---

## **_인덱스란?_**

인덱스가 무엇이냐라고 한다면, 보통 책의 색인이나 사전의 색인과 비교해서 설명한다.

현재 읽고서 내용을 정리하는 SQL레벨업 책에도 색인이 존재한다. 맨 앞에 보면 챕터마다 해당 챕터가 어디에 있는지 쪽 수를 표시하며, 챕터 내부의 하위 내용들도 쪽 수가 표시되어 있다.

그렇기에 보고자하는 챕터가 있다면, 해당 색인을 보고서 빠르게 해당 쪽 수를 피면 된다. 이러한 색인이 없다고 가정하면 원하는 챕터를 보고 싶을 때 모든 페이지를 펴가면서 찾을 수 밖에 없다.

DB의 인덱스 또한 마찬가지이다. 찾고자 하는 데이터가 있을 때 해당 데이터가 어디에 저장되어 있는지 위치를 알 수 있다면 굳이 테이블의 모든 데이터를 뒤져가며 해당 데이터를 찾을 필요가 없을 것이다.

이럴 때 DB의 인덱스가 책의 색인과 같이 데이터의 위치를 알고 있다.

### **_동작 원리_**

데이터 파일의 블록이 10만개가 있다고 가정할때 select문 실행시

1. server process가 구문분석과정을 마친후 database buffer cache에 조건에 부합하는 데이터가 있는지 확인
2. 해당 정보가 buffer cache에 없다면 디스크 파일에서 조건에 부합하는 블럭을 찾아 database buffer cache에 가져온 뒤 사용자에게 보여줌

3. 이 경우 index가 없으면 10만개 전부 database buffer cache로 복사한뒤 풀스캔으로 찾게됨

4. index가 있으면 where절의 조건의 컬럼이 index의 키로 생성되어있는지 확인한 뒤, 인덱스에 먼저 가서 조건에 부합하는 정보가 어떤 ROWID를 가지고 있는지 확인 후 ROWID에 있는 블럭을 찾아가 해당 블럭만 buffer cache에 복사

참고 : https://ssunws.tistory.com/45

정리하면, 인덱스가 정의되어 있는게 없다면, 보통은 풀 스캔을 통해 데이터를 전부 가져온 뒤에 조건에 맞는 데이터들을 찾는 것이다.

반대로, where절의 컬럼이 인덱스로 정의되어서 인덱스 사용이 가능한 경우에는 인덱스에서 조건에 적은 값과 일치하는 KEY를 찾아 리프노드까지 이동하고, 해당 리프노드에서는 해당 KEY와 일치하는 데이터들의 주소를 알려준다.  
그럼 이후에는 해당 물리적 주소를 통해 바로 원하는 데이터들만을 손쉽게 가져오는 것이다.

인덱스는 B+ tree 알고리즘을 사용하며, B+ tree 알고리즘은 B- tree 알고리즘에서 발전된 알고리즘이다.

따로 내용을 정리했으니 참고  
https://github.com/sksrpf1126/study/blob/main/DB/%5BDB%5D%20B-tree%2C%20B%2Btree.md

</br>

### **_풀 스캔 VS 인덱스_**

</br>

  <p align = "center">
  <img src="https://user-images.githubusercontent.com/62879192/211144231-368d9bba-8b7f-4395-b897-3b62e3818321.png" width = 80%>
  </p>

출처 : https://kyungyeon.dev/posts/66

위 그래프를 보면 알 수 있듯이, 인덱스가 적용된다고 해서 반드시 풀 스캔보다 성능이 좋은 것은 아니다.  
 데이터의 양이 적을경우에는 오히려 풀 스캔이 더 좋을수가 있는데, 그 이유는 결국 인덱스도 어딘가에 저장되어 있으며, 인덱스를 사용할 때 내부적으로 B+ tree 알고리즘에 의한 연산이 적용이 된다.  
 즉, 데이터의 양이 적을 때는 불필요하게 인덱스를 사용하는 것보다 풀 스캔하는 것이 효율적이라는 것이다.

그렇다고 데이터의 양이 많을 때 인덱스를 적용하면 반드시 효율적이라는 것은 아니다.  
 효율적으로 사용하기 위해서는 어떻게 해야하는지를 알아보자.

  </br>

---

## **_인덱스를 잘 활용하려면_**

크게 2가지가 존재하며, 우선 첫번째로 인덱스의 필드집합의 카디널리티가 높을수록 좋다는 것이다.  
카디널리티란, 중복도를 의미하며 카디널리티가 높으면 중복도가 낮다는 표현이고, 카디널리티가 낮으면 중복도가 높다는 표현이다.  
즉, 인덱스로 구성한 필드의 집합들이 중복도가 낮을수록 효율적이라는 것이다.

다음으로는 선택률이 5% ~ 10% 이하일 때 인덱스를 타는게 효율적이라는 것이다.  
선택률이란 100개의 레코드 중에 1개의 레코드를 조건문을 통해 선택한다면, 선택률은 1%이다.  
인덱스는 조건에 일치하는 특정 데이터들을 가져오는데에 효율적이며, 특정 데이터들이 많아질수록 인덱스의 연산에 대한 비용이 증가할테고 5% ~ 10%가 넘어버리면 오히려 풀 스캔이 더 효율적일 수 있다고 한다.  
(과거에는 20%정도가 적절하다고 했지만, 하드웨어의 성능 향상으로 점점 낮아지는 것 같다)  

마지막으로 Insert, Delete, Update와 같은 갱신질의를 많이 사용이 되는 테이블에는 인덱스 사용을 피해야 한다.  
인덱스로 걸어둔 필드의 집합들이 갱신에 의해 변경이된다면, 인덱스 또한 변경이 이루어진다. insert나 delete의 경우에는 B+ tree 알고리즘에 노드의 삽입 또는 삭제가 일어나며, update의 경우 B+ tree는 Delete가 발생한 후, Insert가 발생한다. 즉, 2배의 작업이 소요된다.  

이렇게 테이블이 갱신될 때마다 인덱스 또한 연산에 의해 갱신을 해야되므로, 갱신이 자주일어나는 테이블인 경우에는 적합하지 않다.  


</br>

---

## **_인덱스로 성능 향상이 어려운 이유_**

첫번째로, 압축 조건이 없는 경우이다. 무슨 말이냐면 인덱스는 where구문에 의해 key값과 일치하는 data를 찾아 조건에 맞는 데이터들의 물리적 위치를 얻어내 바로 접근해서 가져오는 것이다.  
그런데 압축 조건(where구문)이 존재하지 않는다면 애초에 인덱스가 적용이 되지 않는다.
