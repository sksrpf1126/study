# **_DBMS 아키텍처_**

해당 내용은 [SQL 레벨업](http://www.yes24.com/Product/Goods/24089836) 책을 통해 공부한 내용입니다.

---

## **_구조_**

</br>

  <p align = "center">
  <img src="https://user-images.githubusercontent.com/62879192/209102104-83a65ab0-ac3d-4de8-865d-34341e3c7957.png" width = 70%>
  </p>

- 출처 : https://velog.io/@tastestar/DBMS-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98

### **_쿼리 평가 엔진_**

사용자가 작성한 SQL 구문을 받아서 분석을 한다. 이후 해당 SQL 구문에 따라 데이터를 어떻게, 어떠한 순서대로 실행할지를 결정하는데, 이 결정에 대한 계획을 **_실행 계획_** 이라고 한다.

### **_접근 메서드_**

위 실행 계획을 기반으로 작동하는 방법을 "접근 메서드"리고 한다.

### **_버퍼 매니저_**

DBMS는 처음에 실행될 때 OS로부터 메모리 공간을 할당 받는데, 이 때 일부 메모리 공간을 따로 할당받아서 사용한다. 이 때의 메모리 공간을 "버퍼" 라고 하며, 이 공간을 관리하는 것이 "버퍼 매니저" 이다.

### **_디스크 용량 매니저_**

데이터는 결국 DBMS가 종료가 되고 컴퓨터가 꺼진다 해도, 디스크에 영구적으로 저장이 되어 있어야 한다. 이 떄 데이터를 디스크의 어디에 어떻게 저장하고, 관리할지를 "디스크 용량 매니저" 가 맡아서 처리한다.

### **_트랜잭션 매니저와 락 매니저_**

DB 트랜잭션을 처리할 때 사용되는 것이 "트랜잭션 매니저" 이며, "락 매니저"는 여러 사용자가 동시에 같은 데이터를 건드리는 경우에는 문제가 발생할 수 있는데, 이를 방지하기 위해 한 명의 사용자만이 접근할 수 있도록 관리하는 것이다.

### **_리커버리 매니저_**

데이터는 매우 중요하다. 그래서 DBMS가 작업 중에 문제가 생겨서 데이터가 날라가버리면 비즈니스적으로 매우 큰 문제가 발생할 수 있는데, 이를 대비하여 백업 기능과 복구 기능이 존재하며 이를 담당하는 것이 "리커버리 매니저"이다.

</br>

---

### **_버퍼 종류_**

버퍼에는 2가지로 나뉜다.

데이터 캐시
로그 버퍼
데이터 캐시는 select 구문 즉, 데이터를 읽어 들여오는데에 특화된 버퍼라고 생각하면 된다. 자주 읽어 들여오는 데이터들을 미리 데이터 캐시에 올려놓고서, select를 통해 조회하면 접근 속도가 빨라 성능이 향상된다.

로그 버퍼의 경우에는 갱신 질의(Insert, Update, Delete 등)와 관련된 버퍼로, 갱신 질의가 들어오면 갱신 질의를 바로 데이터에 적용하지 않고 갱신 정보를 로그 버퍼가 가지고 있는다. 이후 SQL 질의가 끝나거나 Commit을 통해 적용을 하는 단계에서 해당 정보를 토대로 디스크에 접근해서 데이터를 변경한다.

이렇게 하는 이유는 갱신 질의에 따라 바로바로 디스크에 존재하는 데이터를 변경해버리면, 그 시간동안 다른 사용자들은 대기를 해야하기 때문이다.

## **_DBMS와 메모리 공간_**

왜 DBMS는 버퍼라는 메모리 공간을 따로 할당받아서 사용하는 것일까?  
그 이유는 기억장치의 종류에 따른 장단점으로부터 등장하였다. 디스크(HDD)의 경우에는 대용량의 데이터를 저장할 수 있는 방면에, 접근 속도는 떨어진다. 반대로 메모리(RAM 등)의 경우에는 많은 데이터를 저장할 수는 없지만 접근 속도는 매우 빠르다.

그렇기에 CPU의 연산에 필요한 자원들을 디스크에서 가져오는 것보다는 메모리에서 가져오는 것이 성능적으로 좋을 것이다. 그래서 메모리는 CPU에서 필요한 자원들을 미리미리 디스크에서 가져와서 올려놓는다.

DBMS 또한 이와 같이 많이 접근해서 사용하는 데이터들을 메모리 즉, 버퍼에 올려놓고 사용한다면 성능이 향상될 것이기 떄문에 "버퍼"를 사용하는 것이다.

</br>

### **_버퍼 종류_**

버퍼에는 2가지로 나뉜다.

1. 데이터 캐시
2. 로그 버퍼

데이터 캐시는 select 구문 즉, 데이터를 읽어 들여오는데에 특화된 버퍼라고 생각하면 된다. 자주 읽어 들여오는 데이터들을 미리 데이터 캐시에 올려놓고서, select를 통해 조회하면 접근 속도가 빨라 성능이 향상된다.

로그 버퍼의 경우에는 갱신 질의(Insert, Update, Delete 등)와 관련된 버퍼로, 갱신 질의가 들어오면 갱신 질의를 바로 데이터에 적용하지 않고 갱신 정보를 로그 버퍼가 가지고 있는다. 이후 SQL 질의가 끝나거나 Commit을 통해 적용을 하는 단계에서 해당 정보를 토대로 디스크에 접근해서 데이터를 변경한다.

이렇게 하는 이유는 갱신 질의에 따라 바로바로 디스크에 존재하는 데이터를 변경해버리면, 그 시간동안 다른 사용자들은 대기를 해야하기 때문이다.

</br>

### **_메모리 휘발성 문제_**

버퍼는 메모리에서 할당받아서 사용하게 된다. 그런데 메모리는 "휘발성" 이라는 특징을 가진다. 즉 프로그램에 장애가 발생하거나, 컴퓨터가 종료가 되어버리면 메모리의 데이터들은 전부 날라가버리게 된다.

데이터 캐시에 존재하는 데이터의 경우에는 다시 읽어서 올려두면 되지만 갱신 정보를 저장하는 로그 버퍼의 경우에는 디스크에 존재하는 실제 데이터를 갱신하기전에 날라거비린다면 큰 문제가 발생할 것이다.  
이를 보완하기 위해서 DBMS는 갱신 정보를 로그 파일이라는 개념으로 디스크에 저장해 둔다.

디스크에 저장하기 때문에 결국 "지연"이 발생할 수 있는데, 이러한 설정을 끌 수가 있다. 하지만 데이터의 정합성은 보장이 안되기 때문에 **_"트레이드 오프"_** 가 발생한다.

</br>

### **_버퍼와는 또 다른 메모리 공간_**

버퍼와는 또 다른 메모리 공간을 DBMS는 할당받아서 사용한다. 바로 "워킹 메모리" 라는 이름을 가진 공간이다.

해당 메모리가 사용되는 시점은 정렬(GROUP BY), 집합 연산, 해시 결합 등에서 사용이 된다.

즉 연산 작업이 필요한 위 구문들의 경우에는 디스크 보다는 접근 속도가 빠른 메모리를 활용하는 것이다.

</br>

---

## **_DBMS와 실행 계획_**

</br>

  <p align = "center">
  <img src="https://user-images.githubusercontent.com/62879192/209123298-3566fa63-0b16-4242-97a1-7138a060b2ba.png" width = 70%>
  </p>

- 출처 : https://velog.io/@manx/SQL-%EB%A0%88%EB%B2%A8%EC%97%85-Ch.1-DBMS-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98

위 이미지는 쿼리 평가 엔진의 내부 동작 구조이다.

파서의 역할은 SQL 구문이 문법에 맞는지를 판별한다. 이후 문제가 없는 구문이라면 옵티마이저에서 해당 SQL구문에 맞는 실행 계획을 세우며, 각각의 계획에 따라 비용을 평가하는 단계를 거친다.

실행 계획을 세울 때에 카탈로그 매니저가 관여하는데, 카탈로그 매니저는 DBMS의 내부 정보를 테이블의 형태로 저장하며, 테이블과 관련된 정보나 인덱스에 관련된 정보들을 저장하고 있는다.

이후 플랜 평가 단계에서는 최적의 실행 계획을 선택한다.

### **_카탈로그 매니저_**

카탈로그 매니저를 통계 정보라고도 한다.  
DBMS는 실행 계획에 따라 어떤 테이블을 먼저 읽어들일지 그리고 읽어들일 때에도 인덱스를 활요할 것인지 아닌지 등의 계획을 세우는데 이 때 통계 정보를 토대로 계획을 세운다.

카탈로그 매니저가 아주 오래된 정보를 가지고 있거나, 실행 계획을 세우는데에 필요한 통계정보가 부족하다면 최적의 실행 계획이 아닌 엉뚱한 실행 계획이 만들어지고 이후 해당 방법으로 동작되기 때문에 성능에 매우 큰 영향이 간다.

마지막으로, 실행 계획을 수동으로 직접 수정할 수 있는데 이러한 이유는 옵티마이저가 아직까지는 부족한 점이 있어 항상 최적의 실행 계획만을 만들지는 않기 때문이다.
