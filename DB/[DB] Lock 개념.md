# **_DB Lock 개념_**

## **_락(Lock)이란?_**

데이터베이스를 다룰때 알아야 할 개념 중 하나가 바로 "LOCK(락)" 이다.  
락은 데이터베이스를 사용하는 여러 사용자들이 같은 데이터를 동시에 접근할 때 동시에 접근하지 못하도록 즉, 해당 데이터의 무결성과 일관성을 지키기 위해 사용하는 것이 "락"이다.

</br>

## **_Lock level_**

락을 걸 수 있는 레벨은 다음과 같다.

  <p align = "center">
  <img src="https://user-images.githubusercontent.com/62879192/210540496-c1f12138-4ed8-489d-9dbb-aa0ba4ab9a88.png" width = 50%>
  </p>

출처 : https://www.sqlpassion.at/archive/2016/05/16/why-do-we-need-intent-locks-in-sql-server/

- Database Level  
  데이터베이스 자체에 락을 거는 경우로, 보통 스키마를 변경하거나 DB의 소프트웨어 버전을 업데이트 할 때 사용

- Table Level  
  테이블에 락을 거는 경우로, 테이블과 관련 인덱스까지 모두 잠긴다.  
  테이블에 영향을 주는 경우 사용한다.

- Page Level
  페이지를 기준으로 락을 건다.  
  이때 페이지란, 보통 DB에 저장되는 데이터는 8KB 단위의 블럭으로 저장하는데, 이 때 하나의 블럭을 페이지라고 한다.

- Row Level
  1개의 행을 기준으로 락을 건다.

</br>

## **_락 종류_**

</br>

### **_공유 락_**

공유 락은 데이터(행 = row)를 읽을 때 주어지는 락으로 Read Lock이라고도 불린다. Shared의 앞 글자를 따서 S로 표기한다.  
읽는 행위로는 데이터의 일관성과 무결성을 해치지 않기 때문에 공유 락끼리는 동시에 접근이 가능하다. (여러 사용자가 각자 공유 락을 얻고서, 같은 데이터를 읽을 수 있음)

### **_베타 락_**

베타 락은 데이터를 변경하는 명령들을 보고서 실행하기 전에 주워지는 락으로 Write Lock이라고도 불리며, X로 표기한다.  
베타 락이 존재하는 경우 다른 사용자(세션)들은 해당 자원에 접근할 수가 없다.

만약, 같은 데이터를 기준으로 두 사용자가 공유 락을 건 상태이다. 그리고 한 사용자가 해당 데이터를 변경해 버린다면 다른 사용자는 원하던 데이터가 아닌 바뀌어버린 데이터를 읽게 될 것이다.  
이러한 경우를 방지하기 위해서 베타 락이 존재한다.

### **_업데이트 락_**

업데이트 락은 베타 락(X)를 걸기 전에 데드 락을 방지하기 위해 사용되는 락이다. 보통 update 구문의 where 조건의 실행 과정 중 동작하며, "컨버젼 데드락"을 막는 용도로도 사용 된다.

```
컨버젼 데드락이란?

예시로, update구문의 데이터를 변경할 때, 기존의 데이터를 가져와야 하며, 가져오기 위해 select문을 수행한다. 이 때, 공유 락을 걸게 되고, 이후 해당 데이터를 변경할 때 베타 락으려 변환을 시도하는데, 다른 세션(사용자)에서 락(공유 락도 포함)이 걸려있을 경우에 변환 시도를 실패하게 된다. 그리고 이를 컨버젼 데드락(Conversion Deadlock)이라고 한다.
```

### **_내재 락_**

내재 락은 해당 데이터나 락을 걸 수 있는 곳들(페이지, 테이블)에 대해서 락을 걸 수 있는지 여부를 판단하는 용도로 사용이 되며, 다른 락을 걸기 전에 내제 락을 걸기 때문에 앞에 I를 붙인다. (IS, IU, IX, SIX)

예를 들어 어떤 데이터에 A 사용자가 락을 건 상태에서 B 사용자가 테이블에 락을 걸기 위해서는 다른 사용자(이때 A)가 해당 데이터에 락을 걸었는지 판단을 할 필요가 있다. 내재 락이 없다고 가정하면 테이블의 전체 데이터를 뒤져가며 락의 유무를 판별해야 한다.  
하지만 A 사용자가 데이터에 락을 걸 때 해당 데이터의 상위 객체(페이지, 테이블)에 내재 락을 걸어둔다면 불필요한 과정없이 바로 락이 내재가 되어있다는 것을 판별할 수 있다.

의도 공유 잠금(IS), 행 수준에서 공유 잠금이 있는 경우  
의도 업데이트 잠금(IU), 행 수준에서 업데이트 잠금이 있는 경우  
Intent Exclusive Lock(IX), 행 수준에서 배타적 잠금이 있는 경우

</br>

---

## **_DB LOCK 계층 정리_**

만약 데이터를 읽고, 변경하는 행위를 하는 경우 아래와 같이 락이 동작하게 된다. (보통의 경우)

1. 데이터를 읽기 전 공유 락을 걸기 전에 내제 락(IS)을 건다.
2. 이후 데이터를 읽는 행위를 할 때 공유 락(S)을 건다. (해당 데이터에 공유 락만 존재하는 경우, 다른 사용자들 또한 공유 락을 걸 수 있음)
3. 이후 데이터를 변경하기 위해서 베타 락(X)으로 변환을 시도하며, 다른 사용자의 락(공유 락 포함)이 존재하는 경우에는 해당 락이 풀릴 때 까지 대기한다.
4. 베타 락(X)으로 변환이 가능하다면, 변환하기 전에 내제 락(IX)을 건다.
5. 이후 베타 락으로 변환을 한다.

내제 락에 IS, IX말고도 SIX가 존재하는 것을 보면 공유 락인 경우에는 내제 락을 안거는 경우도 존재하는 것 같다.

</br>

---

# **_출처_**

https://velog.io/@koo8624/Database-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EB%9D%BDLock%EC%9D%98-%EC%A2%85%EB%A5%98%EC%99%80-%EC%97%AD%ED%95%A0  
https://www.sqlpassion.at/archive/2016/05/16/why-do-we-need-intent-locks-in-sql-server/  
https://chrisjune-13837.medium.com/db-lock-%EB%9D%BD%EC%9D%B4%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80-d908296d0279  
https://www.gpgstudy.com/forum/viewtopic.php?t=6116 [컨버전 데드락]  
https://eddie-park.tistory.com/20 [Lock Level]
