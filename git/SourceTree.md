# SourceTree

### ***주의***
해당 내용은 저의 사용방법에 초점을 맞추어서 설명합니다. 그렇기에 소스트리에서 제공하는 더 많은 기능을 알고싶으면 따로 찾아보면서 써보셔야 합니다.  

또한, SourceTree와 본인의 Git과 연동을 했다고 가정하므로, 연동에 대한 내용은 없습니다! (구글에 찾으면 다 나와요)

---

## ***소스트리란?***

기존에는 Git Bash라는 것으로 CLI방식 즉, 커맨드창에서 직접 명령어를 치면서 작업을 했다.  
하지만 해당 방식은 실제로 어떻게 동작되는지 눈으로 따라가기가 힘들다. 그러니까 사용자에 친화적이지 않다는 것이다.  
사실 Git뿐만 아니라 우리 개발자들은 이미 이러한 툴들을 계속 쓰고 있다.  
자바의 경우, 메모장으로 코딩을 하고, cmd창에서 컴파일 및 실행까지 할 수 있다. 하지만 해당 방법은 너무 불편하다...  
그렇기에 우리는 이클립스나 인텔리제이라는 툴을 통해서 UI형태로 편하고 효율적으로 개발을 할 수 있게 된다.  
DB의 경우에도 Oracle은 SQL Developer가 하나의 예시이고, MySql에서는 WorkBentch라는 돌고래 모양의 툴을 통해서 UI로 쉽게 사용할 수 있는 것이다.  

소스트리도 이와 같다. Git이라는 것을 좀 더 사용자가 편하게 쓰기위해서 UI형태로 제공되어지는 하나의 툴이라는 것이다.  

### ***번외) 처음부터 소스트리 쓰는 것을 반대하는 이유***
결국 소스트리는 우리가 명령창에서 명령어를 치는 행위를 단순히 마우스 조작만으로 해당 명령어가 실행되게끔 만들어진 툴이다.  
하지만 그만큼 한계가 존재한다. 여러 사람이 협업을 하다가 레포지토리의 내용이 꼬여서 롤백을 해야한다거나, 원인이 되는 부분을 제거해야하는 경우에는 문제가 복잡해질 수 있기 때문에 소스트리가 제공해주는 기능들로는 해결이 안될 가능성이 높다.  
그런데, 처음부터 명령어 방식이 아닌 소스트리의 방식에 익숙해진 사용자의 경우에는 소스트리가 제공해주는 방식(기능) 외로는 벗어나지 못해 한계에 부딪히게 된다. 결국 명령어를 직접 쳐서 해결해야 한다는 것이다.  


추가적으로 소스트리뿐만 아니라 이클립스나 인텔리제이 자체에서도 Git을 쉽게 연동하고 핵심 명령어들을 UI형식으로 제공해준다. (인텔리제이는 진짜 잘 되어 있다)  
그래봤자, 해당 툴들에서도 git의 명령어들을 UI형태로 제공해줄 뿐 실제로는 명령어 자체가 동작하기 때문에 CLI방식으로 명령어를 치면서 git을 공부한 분들은 동작원리를 알기에 다른 방식으로 넘어가도 금방 적응한다는 장점이 있다.  

---


## ***소스트리와 로컬 레포지토리 연결***

소스트리를 본격적으로 사용해 보자. (하기 전에 소스트리와 본인의 git계정 연동해두기)

<p align ="center"><img src="https://github.com/sksrpf1126/study/assets/62879192/6e5232dc-5f03-4c5d-ba4b-9ee12b5f8ae6" width = 100%></p>

아마도? 처음 본인의 git계정과 소스트리를 연동하면 위와 같은 화면이 나타날 것이다. (연동을 안한상태에서도 동일할수도)  
오래전에 연동을 해놓고 사용하다보니, 처음에 어떻게 보이는지는 잘 기억이 나지 않는다...  

결국 무언가 로컬에서 작업 후에 원격 레포지토리로 작업 내역을 반영하기 위해서는 ***"로컬 레포지토리"*** 를 거쳐야 한다.  
그래서 우선적으로 해야하는 것이 소스트리와 로컬 레포지토리를 연결하는 것이며, 연결 방법은 크게 3가지로 나뉘기 때문에 하나씩 정리해볼 것이다.  

위에 빨간박스 4개에 번호를 매겨놓았으며, 지금부터 하나씩 알아보자. 

### ***1번 (New Tab)***  

1번에 검은 글씨로, New Tab이라고 적혀있을 것이며, 해당 탭의 아래에는 Local, Remote, Clone, Add, Create와 같은 메뉴가 존재하며 기본으로 Local 메뉴가 선택이 되어있을 것이다.(Remote 부분과 Create부분은 거의 사용할 일이 없기에 넘어간다)  
탭의 오른쪽에 + 모양이 보이는데, 누르면 또 하나의 탭이 생길 것이다. 이후에 본인의 로컬 레포지토리와 연결을 하는 순간, 해당 탭은 본인의 로컬 레포지토리의 상태를 보여주는 하나의 화면이 나타날 것이다. (어떻게 보이는지는 2번 방식, 3번 방식, 4번 방식에서 보여줄 것이다)  
그리고 기본으로 선택된 Local 메뉴에서 보이는 메인 화면에는 로컬 저장소라고 적혀있으며, 아래에 많은 저장소들이 보인다. 저 저장소들은 이전에 소스트리에 연결해놓은 내 로컬 저장소들의 목록이다.  
처음 소스트리를 쓰는 분들은 본인의 로컬 레포지토리를 소스트리에 연결을 안해놨을테니 아무 목록도 안보일 것이다.  

소스트리에서 로컬 레포지토리와 연결하는 방법은 크게 3가지가 존재하며, 2번, 3번, 4번의 빨간상자가 바로 그 방법들이다.  
그러면 이제 각각의 방법으로 소스트리를 통해 내 로컬 레포지토리를 해당 탭에서 띄어보자!

</br>

### ***2번 (Local 메뉴)***

위에서 설명했듯이, 2번 그리고 뒤에서 설명할 3번과 4번의 방법은 결국 로컬 레포지토리와 소스트리를 연결하는 것이다.  

그 중에서 2번 방식의 경우에는 예전에 소스트리에서 단 한번이라도 연결시켰던 로컬 레포지토리를 목록에서 보여주며, 이를 선택해서 "다시" 연결하는 것이다.  

</br>

<p align ="center"><img src="https://github.com/sksrpf1126/study/assets/62879192/44753253-1cd1-4d1a-a970-85a732e50d8d" width = 100%></p>

</br>

위의 화면에서 빨간 박스부분이 study라는 로컬 레포지토리이며, 지금 이 글이 올라가있는 원격 레포지토리와 연결되어 있는 ***로컬 레포지토리***이다.  
당연히, 소스트리와 연결되었던 적이 있기에 목록에 나타나는 것이다.  
그러면 저 빨간 박스를 더블클릭해보자.  

<p align ="center"><img src="https://github.com/sksrpf1126/study/assets/62879192/571d8286-761b-42f2-8d8f-f897d123122b" width = 100%></p>

</br>

그러면 위와 같은 화면 구성으로 변할 것이다. 그리고 탭에 New Tab이라 적혀 있던 부분에서 내 로컬 레포지토리의 이름으로 변경된 것을 확인할 수 있다.  
그리고 빨간 네모박스 부분을 보면 "파일 상태"라는 부분이 기본적으로 선택되어 있다는 것을 확인할 수 있다.  
위 이미지의 화면 구성은 "파일 상태" 메뉴를 누른 화면 구성이라는 것이다.  


</br>

<p align ="center"><img src="https://github.com/sksrpf1126/study/assets/62879192/d7a26e4d-acdc-4f26-ba21-c64dccf275d4" width = 100%></p>

다음으로 위 화면은, "파일 상태" 메뉴의 아래에 빨간 네모박스를 쳐둔 "history"라는 메뉴를 선택했을 경우 보이는 화면 구성이다.  

위 "파일 상태"의 화면 구성과 지금 "history"의 화면 구성 이 2개만 알면 소스트리를 사용하는데 문제가 없다. 그리고 해당 화면 구성에서 어떻게 사용하는지, 무엇을 보여주는 것인지에 대해서는 3번과 4번 방식으로 로컬 레포지토리를 연결하는 방식까지 설명하고 난뒤에 설명할 예정이다.  

</br>

### ***4번 (Add 메뉴)***

3번은 맨 마지막에 설명하고, 4번부터 우선 정리하겠다.  

4번의 Add 메뉴의 경우에는 기존에 있는 로컬 레포지토리를 소스트리와 "처음 연결" 할 때 쓰는 메뉴이다.  근데 보통은 처음 로컬 레포지토리를 만들 때 소스트리로 바로 연동을 하기 때문에 해당 방법은 거의 쓰이지 않는다.  
하지만 git 기초정복의 내용에서 git bash를 통해서 로컬 레포지토리를 만들어 둔 분들은 개인의 로컬에는 로컬 레포지토리가 있지만 소스트리에는 연결을 안한 상태이기 때문에 해당 방법을 통해서 소스트리와 연결하면 된다.  

해당 실습에서도 git 기초 정복 내용을 정리할 때 사용한 로컬 레포지토리를 가지고 정리할 예정이다.  

</br>

<p align ="center"><img src="https://github.com/sksrpf1126/study/assets/62879192/a4e252f0-2189-4547-adc8-a9d07538a608" width = 100%></p>

소스트리에 새로운 로컬 레포지토리를 연결시킬 것이기 때문에 탭영역에 + 버튼을 눌러서 새로운 탭을 만들고 Add 메뉴를 누르면 위와 같은 화면 구성이 나타날 것이다.  

3번의 빨간 박스를 보면 탐색이라는 버튼이 보인다.  
우리는 해당 버튼을 통해서 우리가 연결시키고자 할 로컬 레포지토리를 찾아줄 것이다.  

</br>

<p align ="center"><img src="https://github.com/sksrpf1126/study/assets/62879192/53e439ff-b228-4b72-9db0-b1c43876b3d5" width = 100%></p>

위와 같이 탐색버튼을 누르면 오른쪽의 폴더를 찾고 선택하는 창이 하나 나타나며, 그 중에서 우리가 연결시키고자 할 로컬 레포지토리의 폴더를 선택하면 된다.  
여기서 선택하는 git-command-local은 git 기초정복에서 만들어둔 로컬 레포지토리로 소스트리와는 한번도 연결을 시키지 않았기에 2번 방식이 아니라 4번 방식인 Add 메뉴를 통해서 추가하는 것이다.  

</br>

<p align ="center"><img src="https://github.com/sksrpf1126/study/assets/62879192/3cf491eb-470c-4930-b16f-48dc21bf4803" width = 100%></p>

연결시키고자 할 로컬 레포지토리를 선택했다면 위와 같은 저장소 종류 옆 글씨에 ***Git 저장소 입니다.*** 라는 문구가 뜰 것이다. 해당 문구가 나타나야 소스트리가 해당 폴더를 로컬 레포지토리라고 인식을 했다는 것이다.  

그 아래의 빨간 네모박스는 소스트리에서의 Tab에 들어갈 이름을 적는 것인데, 나는 그냥 폴더명과 일치시키기 위해서 그대로 냅둔다.  
마지막으로 아래의 파란색 "추가" 버튼을 눌러보자.

</br>

<p align ="center"><img src="https://github.com/sksrpf1126/study/assets/62879192/87f4e634-67f6-4402-9ce7-519059fa6591" width = 100%></p>

그러면 2번 방식에서 study라는 로컬 레포지토리와 연동되어서 보여지는 화면 구성과 동일한 화면이 보이게 된다.(약간 다른데, 그 이유는 워킹 디렉토리에서 올릴 파일이 있으면 2번 방식으 화면으로 보이고, 하나도 없으면 위와 같이 보임)    
위의 탭에서 보면 알 수 있듯이 study라는 탭과 현재 보여지고 있는 git-command-local 탭은 서로 다른 로컬 레포지토리이며, 각각 서로 다른 원격 레포지토리와 연동되어 있다.  

</br>

<p align ="center"><img src="https://github.com/sksrpf1126/study/assets/62879192/1cff0c10-f0ea-405e-963e-d38476fd76dc" width = 100%></p>

위는 history부분이며, 우리가 git 기초정복에서 만들고 올려둔 텍스트 파일과 커밋의 내역이 보여지게 된다.  
눈썰미가 좋은 분들이라면 history 메뉴에서 무엇을 보여주는지 어느정도 보일 것이다. 물론 몰라도 된다. 나머지 3번 메뉴를 설명하고 나서 자세히 설명할 예정이다.  

우리는 이렇게 소스트리와 이전에 git bash 방식으로 만들어둔 로컬 레포지토리를 연결시켰다. 이제 불편하게 git bash로만 작업하지 않고, 소스트리를 통해서 편하게 작업하면 된다!  

</br>

### ***3번 (Clone 메뉴)***

개인적으로 생각하는 가장 많이 쓰이는 방법이다.  
결론부터 말하면, git clone 명령어를 직접 치지않고 소스트리를 통해서 쓰는 것일 뿐이다. (git clone 명령어를 알아야 해당 동작을 이해하는데 도움이 됩니다)  

```
git clone "가져올 원격 레포지토리 주소"  방식으로 명령어를 사용하며, 실제 웹사이트 주소가 아니라 원격 레포지토리의 clone할 주소이며 해당 주소는 git 기초 정복 내용의 git remote add 부분에 정리를 해놓았다.
```

해당 방법은 로컬 레포지토리가 본인의 컴퓨터에 아에 존재하지 않고, 오로지 원격 레포지토리만 존재하여 원격 레포지토리를 그대로 복사(clone)하여 로컬 레포지토리를 만드는 방식이다.  

참고로 원격 레포지토리는 내 github에 있는 레포지토리가 될수도, 다른 사람 github의 레포지토리가 될수도 있는 것이다.  

해당 실습을 위해서 public 접근으로 원격 레포지토리를 하나 만들어봤다.  

<p align ="center"><img src="https://github.com/sksrpf1126/study/assets/62879192/9622f3eb-4c65-48ab-9c3c-69d91457ae21" width = 70%></p>  

위와 같이 public으로 clone-repo 라는 원격레포지토리를 하나 생성하며, README.md 파일 또한 추가해놓았다.  

</br>

<p align ="center"><img src="https://github.com/sksrpf1126/study/assets/62879192/0ba992d2-c47a-4ed6-ab1b-04016975a992" width = 100%></p>

위와 같이 정상적으로 만들어진 것을 확인할 수 있다.  

</br>

<p align ="center"><img src="https://github.com/sksrpf1126/study/assets/62879192/56be21dc-2dc8-4040-9e27-8249630bfd28" width = 100%></p>

테스트용으로 원격 레포지토리에서 바로 test1이라는 파일을 하나 만들어 봤다.  

</br>

<p align ="center"><img src="https://github.com/sksrpf1126/study/assets/62879192/45c40b86-089c-4eb3-9f66-65a1ccaa9687" width = 100%></p>

그리고 git clone을 위한 해당 원격 레포지토리의 clone 주소를 위의 빨간 네모박스의 버튼을 눌러서 복사를 하자.


</br>


<p align ="center"><img src="https://github.com/sksrpf1126/study/assets/62879192/96fc36b1-8159-4658-903d-4cd5d3500417" width = 100%></p>

위와 같이 새로운 탭에 clone 메뉴를 선택하여 아까 복사해둔 clone 주소를 빨간 네모박스에 복사를 하도록 하자.  
그러면 복사한 칸 바로 아래에 git 저장소 입니다. 라는 문구가 나타나면 정상적으로 된 것이다.  
만약 다른 문구가 뜬다면, public 레포지토리가 아닌 private 레포지토리였다던가, 아니면 git 연동할 때 제대로 인증을 안했다던가, 여러 원인이 있을 수 있다.  

</br>

<p align ="center"><img src="https://github.com/sksrpf1126/study/assets/62879192/a4c2075f-4bc1-48f6-9687-e8f51db5e96a" width = 100%></p>

원격 레포지토리를 복사해서 로컬 레포지토리를 만드는 거기 때문에, 로컬 레포지토리가 될 폴더가 있어야 한다.  
나의 경우 위처럼 clone-repo-local 폴더를 만들어서 해당 폴더로 선택하였다.  
로컬 레포지토리로 지정할 폴더를 선택했다면, 아래의 클론 버튼을 누르도록 하자.  

</br>

<p align ="center"><img src="https://github.com/sksrpf1126/study/assets/62879192/2b649785-52b2-470d-935b-4792bbe4b3f2" width = 100%></p>

그러면 이제는 익숙한 화면이 나타난다. 이전에 2번과 4번의 방법으로 로컬 레포지토리랑 연결해서 나타난 화면이 여기서도 나타난다.  
원격 레포지토리를 만들고나서 하나의 파일을 원격 레포지토리에서 직접 생성하였는데, 해당 방법으로 원격 레포지토리를 복사(clone)하여 로컬 레포지토리를 연결시켰더니 그대로 존재하는 것을 확인할 수 있다.  

맨처음 git 기초정복을 정리한 내용에서는 git init -> git add -> git commit -> git remote add -> git push 와 같은 흐름으로 열심히 로컬 레포지토리를 만들고(git init) 원격레포지토리랑 연결해서(git remote add) 파일의 변경사항을 올렸는데(git add -> git commit -> git push) 해당 방법으로 하니까 매우 간단하게 연결되었다.  

정말 간단하기에, 나도 그리고 대부분의 사람들도 해당 방법으로 사용한다.  

```
소스트리를 쓰지 않고 할려면, 로컬 레포지토리로 지정할 폴더로 가서 git bash 키고, git clone "복사한 원격 레포지토리 clone 주소"  만 치면 위 소스트리와 같이 바로 된다.  
소스트리는 그저 git clone을 위와 같이 마우스를 통한 UI만으로 실행시킨 것이다.  
```

</br>

---

## ***메인화면 설명***

로컬 레포지토리를 연결해서 보이는 2개의 메인화면에는 ***"파일 상태"*** 를 보는 화면과, ***"history"*** 를 보는 화면으로 나뉘었엇다.  
해당 내용에서는 각각의 화면이 의미하는 부분들을 설명하겠다. (내가 사용하는 방식 위주로)  

### ***파일 상태 메인 화면***

파일 상태의 메뉴에서 보여지는 메인 화면은 해당 로컬 레포지토리의 워킹 디렉토리 영역과 스테이징 영역의 상태를 보여준다.  
이때, 하나라도 로컬 레포지토리로 커밋할 파일이 존재하냐 안하냐에 따라 보여지는 화면이 달라진다.  

### ***커밋할 파일(변경사항)이 하나도 없을 때***

<p align ="center"><img src="https://github.com/sksrpf1126/study/assets/62879192/87f4e634-67f6-4402-9ce7-519059fa6591" width = 100%></p>

위는 git 기초 정복에서 사용해서 연동시켰던 git-command-local 폴더 즉, 로컬 레포지토리이다.  
 메인 화면의 가운데에 ***"커밋할 내용 없음"*** 이라는 문구만 띄어진 채로 텅텅 비어있다.  
 해당 로컬 레포지토리의 워킹 디렉토리와 스테이징 영역에 작업내역이 아무것도 존재하지 않아 커밋할 내용이 없어서 저렇게 보이는 것이다.  

 그렇다면, 해당 폴더로가서 처음에 만들어둔 텍스트 파일을 수정해보자.  

 당연히 위는 여기서 실습하는 내용일 뿐, 다른 로컬 레포지토리에서 해도 된다.  

<p align ="center"><img src="https://github.com/sksrpf1126/study/assets/62879192/d391183b-1904-40f5-b15b-bcb09a110248" width = 100%></p>

위와 같이 텍스트 파일에 4번째 라인에 내용을 추가하였다.  

</br>

<p align ="center"><img src="https://github.com/sksrpf1126/study/assets/62879192/10acb9b0-47fb-46f6-824b-0ce11cb29f0a" width = 100%></p>

그리고 소스트리로 다시 돌아와면 위와 같은 화면으로 변할 것이다.  

우선적으로 봐야할 부분들을 크게 4개로 나누었다.  

### ***1번***

1번 부분은 이전에 명령어로 배웠던 git commit을 행하도록 도와주는 메뉴이며, 해당 메뉴의 우측 상단에 숫자가 1이 있는 것이 보일 것이다.  
해당 숫자는 변경 내역이 하나가 존재한다는 의미이다.  

```
뒤에서 설명하겠지만 나는 해당 메뉴로 커밋을 하지 않는다.  
이미지의 우측 하단에 커밋이라는 버튼이 비활성화 되어 있는 것이 보이는데, 나는 해당 버튼으로 커밋을 실행한다.
```

</br>

### ***2번***

2번 빨간 네모 박스의 좌측 상단을 보면, ***"스테이지에 올라간 파일"*** 이라고 써져 있다.  
"스테이지" 랑 거의 같은 단어가 git 영역에 존재했었다. 바로 스테이징 영역이다.  
현재 2번의 빨간 네모박스에는 아무것도 존재하지 않는다. 그 이유는 당연하게도 git add의 명령어 그러니까 작업 디렉토리 영역에서 스테이징 영역으로 아무것도 올리지 않았기 때문이다.  

우선은 2번 부분이 소스트리가 해당 로컬 레포지토리의 스테이징 영역을 눈으로 보여주는 곳이라는 것을 잊지 말자.  


</br>

### ***3번***

3번 빨간 네모 박스의 좌측 상단을 보면, ***"스테이지에 올라가지 않은 파일"*** 이라고 써져 있다.  
git 영역에서 스테이징 영역에 올리기 전의 영역을 뭐라고 불렀을까? 바로 작업 디렉토리라고 불렀다.  

즉, 3번 부분은 작업 디렉토리에 존재하는 변경 내역들을 소스트리가 눈으로 보여주는 곳이라는 것이다.  

이따가 history 화면까지 설명한 뒤에 소스트리로 git add부터 git commit, git push 하는 방법을 보여줄 것이니 우선 개념만 알아두자.  

</br>

### ***4번***

4번에서 보여주는 부분은 3번의 파일 목록들 중에서 하나를 선택하면 보이는 부분이다.  
 해당 파일의 제거된 부분(라인)은 빨간색으로, 새롭게 추가된 부분(라인)을 연두색으로 보여준다.  

 이러한 점이 소스트리를 사용하는 이유 중 하나가 된다.  


 </br>

 ## ***history 메인 화면***  

<p align ="center"><img src="https://github.com/sksrpf1126/study/assets/62879192/c9420e22-5dc4-4b93-a3f5-1efcd3ee1012" width = 100%></p>

### ***1번***

사실 1번은 "파일 상태" 화면에서도 보이는 메뉴로, 내 ***"로컬 레포지토리"*** 의 브랜치 현황을 보여주는 메뉴이다.  
브랜이 이름을 더블클릭하거나, 우클릭해서 checkout 메뉴를 선택하면, 해당 브랜치로 전환(이동)이 된다.  
현재는 main 브랜치 외에 따로 만든 브랜치가 없기 때문에 main만 존재한다.  

</br>

### ***2번***

내가 소스트리를 사용하는 큰 이유중에 하나가 바로 해당 부분이다.  
2번의 큰 빨간 네모 박스는 ***"로컬 레포지토리"*** 와 ***"원격 레포지토리"*** 의 git history(커밋 내역)를 "같이" 보여준다.  

뒤에서 실습하면서 다시 보여주겠지만, 2번 빨간 네모박스 안에 또 조그만 빨간박스를 하나 해놨는데 해당 부분에 main이라는 라벨(? 용어를 몰라 라벨이라고 부르겠습니다)과 origin/main 이라는 라벨이 같이 존재한다.  
같은 main이 존재하지만 하나는 origin/가 붙어있는데, 우리는 origin을 잘 알고 있다.  
바로 원격 레포지토리를 origin 레포지토리라고도 부른다고 했었다. 즉, origin/main은 원격레포지토리의 main 브랜치의 커밋 현황을 보여주는 것이고 그냥 main은 내 로컬 레포지토리에서의 main 브랜치의 커밋 현황을 보여주는 것이다.  
그러면 두 개의 라벨이 같은 커밋에 붙어있는 의미는 무엇일까?  
바로 내 로컬의 main 브랜치와 원격 레포지토리의 main 브랜치의 커밋내역이 같다는 의미이고 달리 말하면 두 레포지토리의 상태(파일, 변경내역)가 완전히 동일하다는 의미이다. (git pull 할 것이 없다는 의미)  

</br>

### ***3번***

3번 부분을 보면 순서대로 커밋(커밋 아이디), 작성자, 날씨, 커밋한 사람의 정보를 제공해준다.  
또한, 커밋 메시지를 보여주며 아래에는 커밋할 때 변경한 내역들을 보여준다.  


</br>

### ***4번***

3번의 아래에서 보여주는 변경한 내역들 중에 하나를 선택하면 보이는 부분으로, 변경한 부분을 상세하게 보여준다. (제거한 부분은 빨간색, 추가된 부분은 연두색)

---

## ***직접 사용해보기***

위에서 각 화면의 구성들을 설명하였으며, 이번에는 소스트리를 통해 원격 레포지토리까지 변경사항을 올려보자.  

### ***git add***

<p align ="center"><img src="https://github.com/sksrpf1126/study/assets/62879192/2c6386d6-ce58-499c-9f3b-4a440c8085b2" width = 100%></p>

위 1번 부분을 통해서 워킹 디렉토리에서 변경한 작업내역(파일)이 하나가 있으며, 그 파일 이름이 hello-git.txt 라는 것을 알 수 있다.  
다음으로, 2번을 통해서 해당 파일의 변경내역이 무엇인지 자세히 확인할 수 있다.  

1번 부분의 오른쪽을 보면 + 버튼이 존재하며 저부분을 누르면, 바로 스테이징 영역에 올라가게 된다. 즉, ***git add hello-git.txt*** 명령어를 치는 것과 동일하다는 것이다.  

<p align ="center"><img src="https://github.com/sksrpf1126/study/assets/62879192/8ee8006c-4b70-4701-8114-e23186c76ba1" width = 100%></p>

+버튼을 누르게 되면, 위와 같이 스테이징 영역으로 올라가게 되는 것을 확인할 수 있다.  

</br>

### ***git commit***

<p align ="center"><img src="https://github.com/sksrpf1126/study/assets/62879192/300e4de6-a57d-4063-9938-e7a6318eda03" width = 100%></p>

지금 hello-git은 스테이징 영역이 존재한다. 그럼 이제 로컬 레포지토리로 올리기 위해 commit을 해야한다.  

위 이미지에서 아래의 빨간네모박스 부분이 바로 커밋 메시지를 작성하는 부분으로 나의 경우 SourceTree Git Commit Test 라고 작성하였다.  

이후에 우측 하단의 ***"커밋"*** 버튼을 누르기만 하면 작성한 커밋 메시지로 커밋이 된다.  

명령어였다면 git commit -m "SourceTree Git Commit Test" 가 되어진다.  

그러 이제 커밋버튼을 눌러보자.  

<p align ="center"><img src="https://github.com/sksrpf1126/study/assets/62879192/92077998-bd12-4df4-9d4b-039a08226639" width = 100%></p>

그러면 위와 같이 "파일 상태" 의 화면에서 가운데 문구에 "커밋할 내용 없음" 문구가 띄워진다.  

</br>

<p align ="center"><img src="https://github.com/sksrpf1126/study/assets/62879192/82caaf94-8da2-4887-b140-894bb39cc5e1" width = 100%></p>

위는 history화면으로 넘어온 것인데, 해당 화면이 어떻게 변화가 됐는지 꼭 기억해야 한다.  

위부터 살펴보면, Push라는 메뉴에 숫자 1이 생겼다. 이 의미는 로컬 레포지토리에서 원격 레포지토리로 반영할 내역이 1건 존재한다는 것이다. 그리고 이 1건은 아까 commit한 내역이 되는 것이다.  

그리고 좌측 메뉴에 브랜치 목록이 보여지는 부분을 보자.  
해당 브랜치 목록은 내 로컬 레포지토리에 존재하는 브랜치들이다. 그런데 main이라는 브랜치의 숫자 옆에 1↟ 가 있는데 이 의미는 현재 로컬 레포지토리의 main브랜치가 원격 레포지토리의 main 브랜치보다 1건의 변경사항이 ***"앞서있다"*** 를 의미한다.  
물론 건 수가 여러개라면 숫자도 해당 건 수만큼의 수로 변경된다.  

### ***참고) 그러면 화살표 방향이 반대인 1↓ 이라면?***
화살표 방향이 반대인 1↓ 이면 무엇을 의미할까?  
화살표가 아래를 보고 있다는 의미는 현재 로컬 레포지토리의 main브랜치가 원격 레포지토리의 main 브랜치보다 1건 변경사항이 "뒤쳐져있다" 를 의미한다.  

뒤쳐지는데에는 대표적으로 2가지 경우가 있다.  
1. 본인이 github 페이지로 들어간 뒤 해당 원격 레포지토리로 가서 변경사항을 직접 추가하는 경우에는 원격 레포지토리에는 변경사항이 1건 생기는 것인데, 내 로컬 레포지토리는 해당 내용이 없게 되는 것이며, 이럴 때는 git pull 명령어로 원격 레포지토리가 앞질러나간 부분들을 전부 땡겨와서 내 로컬에도 동일하게 적용시켜야 한다.  

2. 내가 아닌 다른 사람이 원격 레포지토리에 변경사항을 적용하는 경우에도 내 로컬 레포지토리가 뒤쳐질 수 있는것이다. 이럴때도 git pull로 땡겨오면 된다.   

</br>

다음으로 git log가 보이는 가운데 화면을 보도록 하자.  
2개의 빨간 박스로 쳐놨는데, 해당 부분들은 branch의 라벨이다. 위 빨간 박스는 로컬 레포지토리의 main 브랜치의 라벨이고 나머지 하나는 origin/main 즉, 원격 레포지토리의 main 브랜치 현황이라는 것이다.  

현재 commit까지만 했기 때문에 위와 같이 원격레포지토리가 아래에 있는 것이다.  
그럼 여기서 push를 하면 어떻게 될까?  

</br>

### ***git push***

<p align ="center"><img src="https://github.com/sksrpf1126/study/assets/62879192/b71776c7-ba08-452d-b768-c1d5dd5afd25" width = 100%></p>  

나의 경우에는 원격 레포지토리에 영향가는 git push의 경우 위와 같이 빨간 네모 박스의 터미널 버튼을 눌러서 명령어로 git push를 한다.  
더 정확히 말하면, git add, git commit 외에는 명령어로 git을 사용한다.  
그렇다고 나처럼 할 필요는 없다. 아까 위에서 설명한 push 메뉴(버튼)을 눌러서 push를 해도 되고 다른 명령어도 분명히 소스트리에서 기능을 제공해주는 부분이 존재할 것이다.  

이 부분은 각자의 취향에 맞게 하는걸 추천한다.  

다시 본론으로 돌아와서, 이제 위 명령어를 동작시켜보자.  

</br>

<p align ="center"><img src="https://github.com/sksrpf1126/study/assets/62879192/501eed18-11c5-49b2-ac4f-6189b38350c6" width = 100%></p>  

문제없이 동작이 되는데, 나처럼 명령어로 친 분들의 경우 소스트리의 화면이 그대로일 것이다.  
이럴 때 Push 오른쪽에 패치 버튼을 누르면 새로고침이 되어질 것이다. (git fetch 명령어)  

누르면 아래와 같이 화면이 변할 것이다.  

</br>

<p align ="center"><img src="https://github.com/sksrpf1126/study/assets/62879192/c3fa5888-4ded-4cdc-8d89-78cc9a371fa1" width = 100%></p>  

주의 깊게 봐야하는 부분은 바로 빨간 네모 박스 부분이다.  
아래에 있던 origin/main 브랜치가 내 로컬 레포지토리의 main 브랜치와 동등한 위치로 올라와 있다.  
내 로컬 레포지토리와 원격 레포지토리의 상태가 완전히 똑같아진 것이다.  

---

## ***정리***

내가 소스트리를 쓰는 이유는 아래와 같다.  

1. git add, git commit이 매우 쉽다.  
2. 파일의 변경한 내역들을 자세히 볼 수 있다.  
3. git log를 매우 직관적으로 볼 수 있어서 브랜치 현황을 쉽게 파악할 수 있다.

이 외에는 대부분 명령어로 해결한다. 그래도 위 3개만으로도 소스트리를 쓰는 이유에 대해 충분하다고 생각한다.  

또한, 소스트리를 이용하면 branch 명령어를 공부하기가 편하다(git log와 branch 라벨을 잘 표시해주기 때문)

### ***참고) 3명이 공유하는 원격 레포지토리 브랜치 모양(git log 구조)***

위에서는 예시를 들기 위해 혼자 작업한 레포지토리를 기준으로 설명하였다. 그래서 여러명이 작업한 레포지토리의 git log를 보여주는 것도 도움이 될 수 있을 것 같아서 올려놓기로 했다.  

아래 두 이미지는 3명에서 하나의 원격 레포지토리를 공유해서 사용하는 경우이다.  

<p align ="center"><img src="https://github.com/sksrpf1126/study/assets/62879192/5c528646-07c0-44c5-9236-3bd759e40146" width = 100%></p>  

브랜치가 매우 많아지며, git log의 가지도 여러 갈래로 나누어져 있다.  

</br>

<p align ="center"><img src="https://github.com/sksrpf1126/study/assets/62879192/ed850833-5eec-4b80-8764-8bb3dea65441" width = 100%></p>  

3명이니까 이정도 log밖에 안나오지 만약에 10명이 하나의 원격 레포지토리를 공유해서 작업을 한다면 이보다 더 모양이 복잡해질 것이다.  

