# ***중복 로그인 방지***

해당 내용은 [TakeEat](https://github.com/pickpong/takeeat) 프로젝트를 진행하며, 정리한 내용입니다.

해당 글에서는 Spring Security 기반에서 세션관리를 통한 중복로그인 방지에 대한 내용을 정리하였습니다.  

---

## 발생한 문제

중복 로그인을 허용할 경우에 한 기기에서 주문 상태를 확인을 해버리고 삭제를 한다거나 했을 때 다른 기기에서는 이를 알지 못합니다.  

또한, 저희 프로젝트의 경우 일반회원 뿐만 아니라 가게 업주의 경우도 존재하기 때문에 가게 업주의 경우에는 또 다른 문제가 발생할 수 있다고 생각했습니다.  

동일한 계정으로 서로 다른 작업을 수행할 경우, 데이터가 충돌하거나 데이터 불일치가 발생할 수 있습니다.  

그래서 중복로그인을 도입하기로 하였습니다.  

그렇게 스프링 시큐리티 설정에 중복 로그인을 방지할 수 있도록 설정을 추가했지만 동작이 되지 않았습니다. 그래서 이를 해결하고 기억하기 위해 이 글에 정리를 하였습니다.  

#### 적용한 설정 정보는 다음과 같았습니다.  

```java
.sessionManagement((session) -> session //Spring Security가 제공하는 세션방식 설정
                        .maximumSessions(1) //최대 세션 수 1개로 제한
                        .maxSessionsPreventsLogin(false) // 동시 로그인 차단, false인 경우 기존 세션 만료하고 로그인 진행
                        .expiredUrl("/member/login") // 세션이 만료된 경우 이동 할 페이지
                        .sessionRegistry(sessionRegistry()))
```

</br>

---

## 중복 로그인 판단에 대한 동작 원리

동작이 되지 않은 원인을 찾기 위해서는 Spring Security에서 어떻게 동작이 되는지를 알아야 할 것 같아서 찾아봤습니다.  

<p align ="center"><img src="https://github.com/user-attachments/assets/ca0e12d1-2919-4e24-bcb9-afbde12711ab" width = 80%></p> 

maxSessionsPreventsLogin(false)인 경우를 기준으로 동작되는 원리는 위 이미지이며 이를 정리하면 다음과 같습니다.  

1. 사용자 1이 로그인을 하면 서버에 해당 계정에 대한 세션 생성
2. 사용자 2가 사용자 1이 로그인 하였던 동일 계정으로 로그인을 시도하게 되면 여러 SessionManageMentFilter에서 maximumSessions의 값을 확인합니다. 저의 경우에는 1로 설정을 해두었습니다.  
3. 서버는 새롭게 접근을 시도한 사용자 2의 세션을 새로 생성하고 인증을 해주며 사용자 1의 세션은 `session.isExpired() == true`로 변경하여 세션 만료 설정을 해줍니다.  
4. 만료가 true인 상태에서 사용자 1이 서버로 아무 요청을 보낼 경우에 세션의 만료여부를 확인 후 ConcurrentSessionFilter에서 로그아웃을 진행 후 `expiredUrl("/member/login")` 과 같이 설정되어 있는 경로로 보내게 됩니다. 저의 경우 로그인 페이지로 보내도록 했습니다. 

***하지만 위 동작방식만 보면 어디가 원인인지 알수가 없었습니다.***

그러던 중에 다른 글에서 SessionManageMentFilter에서 여러 전략이 동작이 되는데, ConcurrentSessionControlAuthenticationStrategy 클래스가 동시 세션을 관리하는 역할을 담당한다고 합니다.  

그래서 저는 해당 부분에 디버깅을 해서 찾아봤습니다.  

<p align ="center"><img src="https://github.com/user-attachments/assets/b373ca30-43ae-40c2-9638-7b2cc5677787" width = 80%></p> 

그러던 중 위 sessionAuthenticationStrategy안에 delegateStrategies라는 ArrayList타입에 3개의 객체가 존재했고 그 중에 ConcurrentSessionControlAuthenticationStrategy 클래스타입의 객체가 존재하는 것을 확인할 수 있었습니다.  

<p align ="center"><img src="https://github.com/user-attachments/assets/0a680d26-c37f-41f9-a7e6-c82962b015a9" width = 80%></p> 

sessionAuthenticationStrategy는 위와 같이 SessionManagementFilter의 doFilter메서드에서 호출되어 사용되며, onAuthentication 메서드를 호출하고 있습니다.  
그리고 인자로는 request, response뿐만 아니라 위에서 현재 세션에 로그인한 사용자 정보를 담고 있는 Authentication 타입의 객체를 인자로 전달합니다.  

sessionAuthenticationStrategy는 CompositeSessionAuthenticationStrategy타입의 객체이므로 해당 클래스의 onAuthentication 메서드로 가보면 다음과 같이 로직이 작성되어 있습니다.  

<p align ="center"><img src="https://github.com/user-attachments/assets/984e74a8-8476-416c-84eb-5658b5cd7318" width = 80%></p> 

for문을 보면 delegateStrategies에 iterator 메서드를 통해 반복자를 얻어와 위에서 말했던 총 3개의 전략에 대해 반복하며, 각각의 객체에 존재하는 onAuthentication 메서드를 호출하고 있습니다.  

즉, 여기서 동시 세션을 검증하는 역할을 하는 ConcurrentSessionControlAuthenticationStrategy 클래스 또한 해당 부분에서 동작하는 것을 알 수 있었습니다.  

#### ConcurrentSessionControlAuthenticationStrategy.onAuthentication 메서드

<p align ="center"><img src="https://github.com/user-attachments/assets/c58c0c41-fbf5-4b1c-8c94-89629bc8caf9" width = 80%></p> 

중요한 부분은 빨간색 네모 부분이며, getAllSessions 메서드를 호출하며 인자로는 authentication.getPrincipal()을 통해 Principal 타입의 객체를 전달하는 것을 확인할 수 있습니다.  

내부 동작은 아직몰라도 반환되어 저장되는 변수 타입인 `List<SessionInformation> sessions` 만 봐도 로그인한 사용자의 정보와 일치되는 다른 모든 세션의 정보를 가져오고 아래의 `int sessionCount = sessions.size()` 를 통해 세션의 수를 가져와 작업하는 것을 확인할 수 있습니다.  

#### this.sessionRegistry.getAllSessions 메서드

sessionRegistry는 인터페이스이며 이를 구현한 클래스는 단 하나만 존재합니다. 그것은 바로 SessionRegistryImpl 클래스입니다.  

그러면 해당 클래스에 존재하는 getAllSessions메서드의 로직은 아래와 같습니다.  

<p align ="center"><img src="https://github.com/user-attachments/assets/c902247f-a5d0-4ccc-9bf3-f072e4b0dab7" width = 80%></p> 

첫 줄에서 `this.principals.get(principal)`가 동작이 되어집니다.  

```
미리 얘기하면 위 this.rpincipals.get(principal) 부분이 저희 프로젝트에서 중복 로그인이 안되는 원인이 됩니다!!!
```