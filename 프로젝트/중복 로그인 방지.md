# ***중복 로그인 방지***

해당 내용은 [TakeEat](https://github.com/pickpong/takeeat) 프로젝트를 진행하며, 정리한 내용입니다.

해당 글에서는 Spring Security 기반에서 세션관리를 통한 중복로그인 방지에 대한 내용을 정리하였습니다.  

---

## 발생한 문제

중복 로그인을 허용할 경우에 한 기기에서 주문 상태를 확인을 해버리고 삭제를 한다거나 했을 때 다른 기기에서는 이를 알지 못합니다.  

또한, 저희 프로젝트의 경우 일반회원 뿐만 아니라 가게 업주의 경우도 존재하기 때문에 가게 업주의 경우에는 또 다른 문제가 발생할 수 있다고 생각했습니다.  

동일한 계정으로 서로 다른 작업을 수행할 경우, 데이터가 충돌하거나 데이터 불일치가 발생할 수 있습니다.  

그래서 중복로그인을 도입하기로 하였습니다.  

그렇게 스프링 시큐리티 설정에 중복 로그인을 방지할 수 있도록 설정을 추가했지만 동작이 되지 않았습니다. 그래서 이를 해결하고 기억하기 위해 이 글에 정리를 하였습니다.  

#### 적용한 설정 정보는 다음과 같았습니다.  

```java
.sessionManagement((session) -> session //Spring Security가 제공하는 세션방식 설정
                        .maximumSessions(1) //최대 세션 수 1개로 제한
                        .maxSessionsPreventsLogin(false) // 동시 로그인 차단, false인 경우 기존 세션 만료하고 로그인 진행
                        .expiredUrl("/member/login") // 세션이 만료된 경우 이동 할 페이지
                        .sessionRegistry(sessionRegistry()))
```

</br>

---

## 중복 로그인 판단에 대한 동작 원리

동작이 되지 않은 원인을 찾기 위해서는 Spring Security에서 어떻게 동작이 되는지를 알아야 할 것 같아서 찾아봤습니다.  

<p align ="center"><img src="https://github.com/user-attachments/assets/ca0e12d1-2919-4e24-bcb9-afbde12711ab" width = 80%></p> 

maxSessionsPreventsLogin(false)인 경우를 기준으로 동작되는 원리는 위 이미지이며 이를 정리하면 다음과 같습니다.  

1. 사용자 1이 로그인을 하면 서버에 해당 계정에 대한 세션 생성
2. 사용자 2가 사용자 1이 로그인 하였던 동일 계정으로 로그인을 시도하게 되면 SessionManageMentFilter에서 maximumSessions의 값을 확인합니다. 저의 경우에는 1로 설정을 해두었습니다.  
3. 서버는 새롭게 접근을 시도한 사용자 2의 세션을 새로 생성하고 인증을 해주며 사용자 1의 세션은 `session.isExpired() == true`로 변경하여 세션 만료 설정을 해줍니다.  
4. 만료가 true인 상태에서 사용자 1이 서버로 아무 요청을 보낼 경우에 세션의 만료여부를 확인 후 ConcurrentSessionFilter에서 로그아웃을 진행 후 `expiredUrl("/member/login")` 과 같이 설정되어 있는 경로로 보내게 됩니다. 저의 경우 로그인 페이지로 보내도록 했습니다. 

***하지만 위 동작방식만 보면 어디가 원인인지 알수가 없었습니다.***

그러던 중에 다른 글에서 SessionManageMentFilter에서 여러 전략이 동작이 되는데, ConcurrentSessionControlAuthenticationStrategy 클래스가 동시 세션을 관리하는 역할을 담당한다고 합니다.  

그래서 저는 해당 부분에 디버깅을 해서 찾아봤습니다.  

<p align ="center"><img src="https://github.com/user-attachments/assets/b373ca30-43ae-40c2-9638-7b2cc5677787" width = 80%></p> 

그러던 중 위 sessionAuthenticationStrategy안에 delegateStrategies라는 ArrayList타입에 3개의 객체가 존재했고 그 중에 ConcurrentSessionControlAuthenticationStrategy 클래스타입의 객체가 존재하는 것을 확인할 수 있었습니다.  

<p align ="center"><img src="https://github.com/user-attachments/assets/0a680d26-c37f-41f9-a7e6-c82962b015a9" width = 80%></p> 

sessionAuthenticationStrategy는 위와 같이 SessionManagementFilter의 doFilter메서드에서 호출되어 사용되며, onAuthentication 메서드를 호출하고 있습니다.  
그리고 인자로는 request, response뿐만 아니라 위에서 현재 세션에 로그인한 사용자 정보를 담고 있는 Authentication 타입의 객체를 인자로 전달합니다.  

sessionAuthenticationStrategy는 CompositeSessionAuthenticationStrategy타입의 객체이므로 해당 클래스의 onAuthentication 메서드로 가보면 다음과 같이 로직이 작성되어 있습니다.  

<p align ="center"><img src="https://github.com/user-attachments/assets/984e74a8-8476-416c-84eb-5658b5cd7318" width = 80%></p> 

for문을 보면 delegateStrategies에 iterator 메서드를 통해 반복자를 얻어와 위에서 말했던 총 3개의 전략에 대해 반복하며, 각각의 객체에 존재하는 onAuthentication 메서드를 호출하고 있습니다.  

즉, 여기서 동시 세션을 검증하는 역할을 하는 ConcurrentSessionControlAuthenticationStrategy 클래스 또한 해당 부분에서 동작하는 것을 알 수 있었습니다.  

#### ConcurrentSessionControlAuthenticationStrategy.onAuthentication 메서드

<p align ="center"><img src="https://github.com/user-attachments/assets/c58c0c41-fbf5-4b1c-8c94-89629bc8caf9" width = 80%></p> 

중요한 부분은 빨간색 네모 부분이며, getAllSessions 메서드를 호출하며 인자로는 authentication.getPrincipal()을 통해 Principal 타입의 객체를 전달하는 것을 확인할 수 있습니다.  

내부 동작은 아직몰라도 반환되어 저장되는 변수 타입인 `List<SessionInformation> sessions` 만 봐도 로그인한 사용자의 정보와 일치되는 다른 모든 세션의 정보를 가져오고 아래의 `int sessionCount = sessions.size()` 를 통해 세션의 수를 가져와 작업하는 것을 확인할 수 있습니다.  

#### this.sessionRegistry.getAllSessions 메서드

sessionRegistry는 인터페이스이며 이를 구현한 클래스는 단 하나만 존재합니다. 그것은 바로 SessionRegistryImpl 클래스입니다.  

그러면 해당 클래스에 존재하는 getAllSessions메서드의 로직은 아래와 같습니다.  

<p align ="center"><img src="https://github.com/user-attachments/assets/c902247f-a5d0-4ccc-9bf3-f072e4b0dab7" width = 80%></p> 

첫 줄에서 `this.principals.get(principal)`가 동작이 되어집니다.  

```
미리 얘기하면 위 this.principals.get(principal) 부분이 저희 프로젝트에서 중복 로그인이 되어버리는 원인과 관련이 있습니다!!
```

this 즉, sessionRegistryImpl가 가지고 있는 멤버변수들은 아래와 같습니다.  

```java
    private final ConcurrentMap<Object, Set<String>> principals;
    private final Map<String, SessionInformation> sessionIds;
```

즉, `(Set) this.principals.get(principal);` 에서 principal은 현재 로그인한 사용자의 정보이고, 해당 principal에 대하여 ConcurrentMap의 get메서드를 수행합니다. 당연히 해당 사용자의 정보에 일치하는 Key가 principals에 존재한다면 value값인 Set<String>타입이 반환될 것입니다.  

그리고 해당 값을 `Set<String> sessionsUsedByPrincipal` 변수에 저장합니다.  

이후 아래의 로직을 쭉 보면 sessionsUsedByPrincipal 변수가 null이라면 빈리스트를 반환하고 아니라면 sessionsUsedByPrincipal의 사이즈만큼의 ArrayList를 생성하여 `List<SessionInformation> list` 변수에 담습니다.  

이후 var5라는 변수에 sessionsUsedByPrincipal의 사이즈만큼 반복하는 반복자 즉, iterator를 담습니다.  

이후 while문을 수행하는데 `!var5.hasNext()` 가 참이라면 즉, 다음에 반복할 대상이 없다면 그대로 list를 반환하고 아니라면 var5의 다음 것을 String타입으로 변환하여 sessionId라는 변수에 담고 이를 this.getSessionInformation메서드의 인자로 전달하고 반환된 값을 sessionInformation 변수에 담습니다.  

그리고 마지막에 최종적으로 `list.add(sessionInformation)` 로직을 통해 list에 담습니다.  

해당 로직만 봐도 Set<String>에 담겨있는 값은 sessionId라는 것을 유추할 수 있으며 해당 아이디를 통해 세션의 정보를 가져와 list에 담는것을 알 수 있습니다.  

그리고 해당 list를 반환하는데, 해당 list는 `ConcurrentSessionControlAuthenticationStrategy.onAuthentication 메서드` 에 사용이 됩니다.  

해당 메서드의 로직은 위에도 있지만 다시 보면 아래와 같습니다.  

<p align ="center"><img src="https://github.com/user-attachments/assets/c58c0c41-fbf5-4b1c-8c94-89629bc8caf9" width = 80%></p> 

해당 메서드에서는 list의 수 즉, session의 수를 설정에 걸어두었던 세션제한 수(현재 설정값은 1) 와 비교하여 `같거나 초과`가 된다면 이전 세션을 종료하는 방식으로 동작되게 됩니다.  

정확히 말하면 설정한 최대 세션 수와 같을 경우에는 위에서 반환된 list를 반복하여 같은 sessionId가 있다면 문제없이 종료하고 새로운 sessionId가 있다면 `maxSessionsPreventsLogin() false 또는 true` 의 설정 값에 따라 false일 경우 이전 사용자의 세션을 종료하고 true인 경우 현재 로그인한 사용자의 접근을 막습니다.  

최대 새션 수를 초과하는 경우에는 바로 설정 값에 따라 false일 경우 이전 사용자의 세션을 종료하고 true인 경우 현재 로그인한 사용자의 접근을 막습니다.  

### 사용자 A와 사용자 B, 같은 아이디로 로그인했을 때 디버깅을 해보자

그러면 위 로직의 흐름을 알고 있는 상태에서 각각 다른 브라우저에서 같은 아이디로 로그인을 할 때 디버깅을 해보겠습니다.  

우선은 사용자 A 즉, 처음 로그인을 했을 경우 입니다.


