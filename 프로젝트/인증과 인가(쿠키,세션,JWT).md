# **_인증과 인가(쿠키와 세션 그리고 JWT)_**

인증과 인가의 방식에는 여러 방식이 있으며, 그 중에서 대표적으로 많이 쓰이는 쿠키-세션 방식과 JWT방식을 알아보고자 한다.

---

## **_쿠키와 세션_**

</br>

  <p align = "center">
  <img src="https://user-images.githubusercontent.com/62879192/228461174-ff2d350e-5440-4e4a-a472-276ea733761a.png" width = 80%>
  </p>

쿠키와 세션 방식은 위와 같은 프로세스로 인증 및 인가과정을 거친다.  
요약하면 아래와 같으며, 위 이미지의 순서와는 무관하다.

1. 사용자가 id + password 를 서버에 전달한다.
2. 서버 측은 전달 받은 id와 password를 DB를 통해 "인증"을 한다.
3. "인증"된 사용자인 경우에는 서버에서 임의의 난수 값으로 Session Id값을 만들어서 세션 저장소(서버의 메모리 공간)에 저장한다.
4. 서버는 해당 Session Id값을 이후 클라이언트한테 전달(응답) 한다.
5. 이후, 사용자는 새로운 요청을 서버한테 전달할 때 요청 헤더에 이전에 전달받아 쿠키로 저장한 session id값을 담아서 보낸다.
6. 서버는 인증 및 인가가 필요한 요청일 경우에 사용자가 보낸 session Id값을 자신의 세션 저장소에 존재하는지를 판단한다.
7. 존재할 경우 사용자에게 적절한 응답을 해준다.

쿠키 세션 방식은 보통 위와 같이 동작하며 인증 및 인가 과정을 거친다.

</br>

---

## **_JWT_**

  <p align = "center">
  <img src="https://user-images.githubusercontent.com/62879192/228461179-f84537dc-a282-4bc7-b203-521723b906d9.png" width = 70%>
  </p>

JWT는 위와 같이 header, payload, signature 3가지의 정보가 들어있으며, 구분자(.)로 구분된다. 이 3가지 정보는 base64로 인코딩되어 전달하게 되며, signature부분은 인코딩 이후에 헤더에 담겨진 알고리즘의 방식을 사용하여 암호화를 거친다.

- header  
  typ : 토큰의 타입을 지정하며, JWT 토큰인 경우 JWT  
  alg : 알고리즘 방식을 지정, 서명(signature) 및 토큰 검증에 사용된다.

- payload  
  토큰에서 사용할 정보의 조각들인 클레임(Claim)이 담겨 있으며, payload 부분은 JWT토큰을 발급하는 서버 측이 어떠한 정보를 담을 것이냐에 따라 다양한 정보들이 담길 수 있다.  
  하지만, 이부분은 base64로 디코딩하면 쉽게 정보를 확인할 수 있어, 노출되면 안되는 정보(ex : 개인정보)등은 담으면 안된다.

- signature  
  이 부분은 header + payload 정보를 담고 있으며, base64로 인코딩 한 후에 header에 정의한 알고리즘의 방식을 사용하여 암호화를 하며, 서버 측의 secret key와 함꼐 암호화를 한다.  
  이렇게 하는 이유는 토큰이 탈취되어 토큰을 변조해서 사용하는 것을 방지하기 위함이다.

  ```
  토큰의 암호화 방식에는 대표적으로 HS256(HMAC SHA256)과 RS256 방식이 존재하며, HS256은 대칭키 방식이고, RS256은 비대칭키 방식이다.
  변조를 막는 방법을 설명하기에 앞서 HS256의 방식으로 암호화한다고 가정한다.

  서버는 base64로 인코딩한 header와 payload의 정보와 함께 서버가 가지고 있는 비밀 키를 함께 넣어 암호화를 한다. 암호화한 값이 signature 값이 되며, 대칭키 방식이기 때문에 이를 복호화하기 위해서는 서버가 가지고 있는 동일한 비밀 키 값을 사용해야 한다.
  안 그러면 이상한 값이 나온다.

  그러면 만약 해커가 토큰을 탈취했다고 가정하자.
  해커는 header나 payload만을 변조해서 서버측으로 전달해버리면, 서버는 signature 값을 복호화해서 복호화한 header와 payload값을 해커 측에서 변조한 header와 payload값을 비교하며, 값이 다르다면 변조한 것으로 간주한다.

  또 다른 변조로는 해커가 header, payload 뿐만 아니라 변조한 내용을 가지고 같은 알고리즘으로 암호화를 해서 건내주는 경우이다.

  하지만 서버측은 자신의 비밀키로 복호화하게 될 것이고, 해커 측에서 암호화할 때 사용한 키가 서버측의 비밀키와 값이 같지 않다면 복호화한 값이 정상적인 값이 아니게 되버리므로, 변조로 간주할 수 있다.
  ```

</br>

<p align = "center">
<img src="https://user-images.githubusercontent.com/62879192/228461184-c3793fd5-80e1-4cc0-93bd-fd29d98e0402.png" width = 80%>
</p>

</br>

위는 JWT 토큰 방식의 인증 및 인가 과정이다. 아래에서 요약을 하였으며, 위 순서와는 상관없다.

1. 사용자는 Id, password를 서버측으로 전달한다.
2. 서버측은 1번에서 전달한 정보를 DB와 비교한다.
3. 일치할 경우 서버측은 Access Token(JWT) 토큰을 만든다.
4. 이후 사용자에게 해당 토큰을 전달한다.
5. 사용자는 전달받은 토큰을 로컬 스토리지, 쿠키, 세선 저장소 이 3곳중 하나를 택해 저장한다.
6. 이후 사용자는 요청마다 요청 헤더에 저장한 토큰값을 같이 전달한다.
7. 서버는 해당 요청에 대해 인증 및 인가과정을 걸쳐야 한다면 요청 헤더에 토큰의 여부 및 검증을 한다.
8. 검증된 토큰인 경우에는 적절한 응답을 반환한다.

</br>

---

## **_토큰 저장위치_**

토큰 저장위치는 크게 로컬 스토리지에 저장할 것인가, 쿠키에 저장할 것인가로 갈리는 것 같다.  
그런데 저장하는 위치가 중요한가?에 대해서는 XSS와 CSRF를 알아야 한다.

자세한 내용은 https://cjw-awdsd.tistory.com/48 참고

간단하게 요약하면 로컬 스토리지는 XSS에 취약하지만, CSRF에는 안전하다.  
반대로 쿠키에 저장하는 경우에는 XSS에는 쿠키에 httpOnly 속성을 통해 JS에서 사용하지 못하도록 하여 보호할 수 있지만, CSRF에는 안전하지 않다.

하지만 대부분은 쿠키에 저장하여 사용한다. 그 이유는 CSRF나 토큰 탈취를 해결하기 위해 Access Token + Refresh Token 방식을 같이 사용하기 때문이다.

</br>

---

## **_Refresh Token_**

Access Token + Refresh Token이 어떻게 CSRF와 토큰 탈취에 대해서 보안을 챙길 수 있다는 것일까?  
여기에 정확히 말하면 보안을 조금 더 향상시킬 뿐 완벽히 보호할 수 있는 방식은 아니다. 그 이유는 해당 방식에서 알 수 있다.

사용자의 인증 요청에 따라 토큰을 만들 때 Access Token 뿐만 아니라 Refresh Token도 같이 만들며, Refresh Token은 유효기간을 길게 가져가며, Access Token은 유효기간을 짧게 가져간다. 이후 Refresh token은 서버의 DB아 Redis와 같은 저장소에 저장을 하고, 사용자한테는 Access Token와 Refresh Token을 동시에 전달한다.

이후 사용자는 요청을 날릴 때 Access Token만을 전달하며, 서버 측도 해당 토큰만으로 인증 및 인가과정을 거치며 응답을 해준다.  
그런데 Access Token은 유효기간이 짧기 때문에 다시 재발급을 받을 필요가 있다. 하지만 그렇다고 유효기간이 지날때 마다 재로그인을 하는건 사용자에게 매우 번거로운 작업이 될 수 있다.

그렇기에 Access Token의 유효기간이 지났을 때 Refresh Token을 함께 전달하고, 서버측에서는 Refresh Token을 검증하고, 검증이 되었을 경우 새로운 Access Token을 발급하여 전달한다.

이를 통해 Access Token을 탈취당해도 짧은 유효기간을 가지기 때문에 해커 측은 제대로 사용할 수가 없다는 것이다. 하지만, 유효기간을 좀 길게 잡는다거나 해커가 빨리 탍취하여 악용할 시간이 충분하다면 말이 달라진다.

그렇기에 해당 방식이 보안을 조금 더 향상시킬 뿐 완벽한 방안이 될 수 없다고 말한 것이다.

```
Refresh Token을 탍취당하면?
Access Token보다 Refresh Token이 네트워크를 타는 횟수가 더 적기 때문에 탈취당할 확률은 더 적지만, 그래도 해커가 마음만 먹는다면 언제든 탈취할 수 있을 것이다.

그러면 해커가 Refresh Token을 탈취하여 이를 서버로부터 새로운 Access Token을 발급받고, 이를 악용하면?
이는 서버측에서 검증을 통해 어느정도 이를 막을 수 있다.

1. Refresh Token과 유효기간이 지난 Access Token을 같이 전달할 경우에만 새로운 Access Token을 발급해준다.
2. Refresh Token으로 한 번 발급했다면, 해당 Refresh Token을 제거하고 새로운 Refresh Token을 사용한다.

물론, 위 방법으로도 완벽히 막을 수 없다.
그래서 해킹과 보안은 뚫고 막는 행위를 반복할 수밖에 없다고 말하기도 한다. 더 자세한 보안 내용은 아래의 하이재킹 내용을 참고
```

</br>

---

## **_세션 하이재킹, 토큰 하이재킹_**

쿠키-세션방식이든 JWT방식이든 하이재킹(탈취)이 발생할 수밖에 없다. (결국 세션이든, 토큰이든 네트워크에서는 text로 오가기 때문에 둘의 탈취방식이 다르진 않다)

https://onecoin-life.com/22 글에서는 하이재킹과 이를 위한 보안 대응책을 설명한다.

쉽게 정리하면, http가 아닌 https를 통해 네트워크간 데이터 전송을 암호화하여 보내도록 하는 것이다. 그러면 해당 정보를 탈취해도 암호화가 되어 있기 때문에 악용할 수가 없다.

다음으로, 인증에 대한 보안을 강화하는 것이다.

1. 지속적인 재인증 요구
2. 인증된 사용자의 요청의 주소와 같은 정보를 통해 갑자기 상이한 주소에서 요청이 오는 경우에 대한 검증

추가적으로 더 많은 방식에 더 자세한 내용은 필요할 때 찾아보도록 하자.

</br>

---

## **_세션 방식 VS JWT_**

JWT 토큰 방식의 경우 header, payload, signature와 같이 많은 정보를 지속적으로 네트워크에 실어 보낸다. 그에 비해 Session방식은 Id만 실어 보내기 때문에, 세션 방식보다 토큰 방식이 네트워크 비용이 훨씬 더 많이 든다고 한다.

또한, 세션방식은 사용자의 인증 정보를 세션저장소에서 관리하기 때문에 세션이 탈취됐다면 세션저장소에서 제거를 함으로써 무효 처리가 가능하며, 로그아웃 처리나 다른 곳에서 로그인할 경우의 인증정보 제어 등 서버에서 인증정보를 저장함으로써 쉽게 구현이 가능한 부분이 다수 존재한다.

하지만 토큰방식의 경우 서버에서 인증정보를 저장하지 않는 Stateless한 방식이기 때문에 위와 같은 부분들을 제어할 방법이 존재하지 않는다.

여기까지만 보면 JWT 토큰을 사용할 이유가 전혀 없어보인다.

하지만 JWT가 세션방식에 비해 막강한 장점을 가지는 부분이 존재한다. 바로 확장성에 있다.

만약 서버를 여러대로 늘려야 한다면?  
예를 들어 서버가 3대가 있는 경우 세션저장소의 문제점을 보자.

사용자가 1번 서버에서 인증을 하면, 1번 서버의 세션저장소에는 이를 저장한다.  
이후 동일한 사용자가 로그인을 해야지만 정상 응답이 가능한 요청을 2번 서버에 했다.  
여기서 문제는 1번 서버에는 해당 사용자에 대한 인증 정보를 가지고 있지만 2번 서버에는 해당 정보를 가지고 있지 않아 사용자가 로그인을 하지 않았다고 간주해버린다.

하지만 JWT는 서버에서 어떠한 정보도 저장하지 않고 사용자가 전달한 토큰값으로 판단하기에, 확장성에 매우 뛰어나다.

또한, 세션은 서버에서 자장하기 때문에 그 양이 많아질수록 서버에 부담이 가게 된다.

</br>

---

## **_참고_**

https://kbwplace.tistory.com/165 (쿠키, 세션, JWT)  
https://velog.io/@cokkum113/%EC%84%9C%EB%B2%84%EC%9D%B8%EC%A6%9D%EC%84%B8%EC%85%98%EC%BF%A0%ED%82%A4-JWT (쿠키, 세션, JWT)  
https://mangkyu.tistory.com/56 (JWT란)  
https://hwannny.tistory.com/72 (JWT 암호화 방식)  
https://cjw-awdsd.tistory.com/48 (JWT XSS, CSRF 취약점)  
https://onecoin-life.com/22 (하이재킹)  
https://hudi.blog/session-based-auth-vs-token-based-auth/ (쿠키-세션 VS JWT)
